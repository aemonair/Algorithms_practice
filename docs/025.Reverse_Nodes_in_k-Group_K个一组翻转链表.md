
#### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
[[206.reverseLinkedList_反转链表]] [[092.reverseBetween_反转链表_II]]
难度困难

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

**输入：** head = [1,2,3,4,5], k = 2
**输出：**[2,1,4,3,5]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

**输入：** head = [1,2,3,4,5], k = 3
**输出：**[3,2,1,4,5]

**提示：**

-   链表中的节点数目为 `n`
-   `1 <= k <= n <= 5000`
-   `0 <= Node.val <= 1000`
---- ----
递归：
```cpp
// p a b c x y z
// p c b a x y z
class Solution {
public:
    ListNode* reverse(ListNode * head, int k)
    {
        ListNode * cur = head;
        for (int i = 1; i < k&& cur; i++) {
            cur = cur->next;
        }
        if (cur == nullptr || k == 1) {
            return head;
        }
        cur = head;
        ListNode * pre = new ListNode(-1, cur);

        // p c t
        // p 1 c t
        for (int i =1; i < k; i++) {
            ListNode * temp = cur->next;
            cur->next = temp->next;
            temp->next = pre->next;
            pre->next = temp;
        }
        cur->next = reverse(cur->next, k);
        return pre->next;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode * newhead = reverse(head, k);
        return newhead;
    }
};

// 递归时，判断 k个反转后，是否能返回head；并通过head->next->next=head 进行反向；
// 若到最后则，next=nullptr；
// 遍历循环时，通过 dummy 节点->next = newhead_;
// 1<-2  3->4->5
//  new  next
//  dummy->next = newhead
// p(-1) ->next = newhead(2)
// pdummy = 1(phead)
// phead = next_(3)
class Solution {
public:
    ListNode * next = nullptr;
    ListNode* reverseK(ListNode* head, int i ,int k)
    {
        if (i == k || head == nullptr || head->next == nullptr){
            if (i< k && head->next == nullptr){
                next = nullptr;
                return head;
            }
            if (head->next==nullptr){
                next = (ListNode *)0x1;
                return head;
            }
            // head
            // 1 2 3
            // nullptr 提前结束，不用交换
            // head head 到最后一个，要交换
            // head next 未到最后一个，有next，要交换
            next = head->next;
            return head;
        }
        auto phead = reverseK(head->next, i+1, k);
         if(next){
             head->next->next = head;
             head->next = nullptr;
             return phead;
         }else{
             return head;
         }
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (k ==1 || head == nullptr){
            return head;
        }
        // 1->2->3->4->5
        // 1<-2  3->4->5
        //  new  next
        //  oldhead->next = newhead
        // p(-1) ->next = newhead(2)
        // pdummy = 1(phead)
        // phead = next_(3)
        //
        // 1<-2  3<-4  5
        //         new next
        // p(2) -> next = newhead(4)
        // pdummy = phead(3)
        // phead = next_(5)
        // 2->1  4->3  5
        //  oldhead->next = newhead
        // pdummy(3) -> next = 5
        // pdummy = phead(5)
        // phead() = nullptr
        //

        ListNode * dummy = new ListNode(-1, head);
        ListNode * pdummy = dummy;
        ListNode * phead = head;

        while(phead){
            int i = 1;
            auto newhead_ = reverseK(phead, i , k);
            pdummy->next = newhead_;
            pdummy = phead;
            phead = next;
            if(next==(ListNode *)0x1){
                phead = nullptr;
            }
            for(auto x= pdummy; x!=nullptr; x=x->next){
                std::cout << x->val << " ";
            }
            std::cout << std::endl;
        }
        return dummy->next;
    }
};
```
头插：
```cpp
// 主要是 每次维护着 有序的链表，当k次完成后，更新prev为curr，且curr为prev->next;
// -1->1->2->3->4->5
// p   c
//
// -1->2->1->3->4->5
//        p  c
// -1->2->1->4->3->5
//
ListNode* reverseKGroup(ListNode* head, int k) {
    // write code here
    // 1 2 3 4 5
    // 3 2 1 4 5
    ListNode * dummy = new ListNode(-1);
    dummy->next = head;
    ListNode* pre = dummy;
    ListNode* last = head;
    while (last) {
        ListNode* cur = pre->next;
        ListNode * last = cur;
        for (int i = 1; i < k && last; i++) {
            last = last->next;
        }
        if (last == nullptr) {
            break;
        }
        // p c n
        // p 1 c t
        for (int i = 1; i < k; i++) {
            ListNode* temp = cur->next;
            cur -> next = temp->next;
            temp->next = pre->next;
            pre->next = temp;
        }
        printList(dummy->next);
        pre = cur;
    }
    return dummy->next;
}
```
---
```cpp
/*
 * -1->1->2->3->4->5->6
 * -1->1->2->3->4->5->6->7->8->9
 *     1<-2<-3 4->5->6
 *     |     p c
 *      \     /
 *       ----
 * -1->3->2->1->4->5->6->7->8->9
 *           d
 * temp = pdummy(-1) -> next (1)
 * pdummy(-1)->next(1)->next = curr(4)
 * pdummy(-1)->next() = prev(3)
 * pdummy = temp(1)
 * 记录每个k组变化之后的前后位置，用一个标记pdummy串联起来，
 * 记录当前头部的下一个位置，由于当前最后一个是prev，下一个最开始是curr，
 * 则将旧头部的下一个(1)指向当前的头部 即curr，例如 -1 ->next(1)->next = curr(4)
 * 旧头部(-1)的下一个指向prev(3),这样，下次就能从3 得到4得到下一个起始位置；
 * -1->3->2->1->4<-5<-6  7->8->9
 *     3->2->1  4<-5<-6  7->8->9
 *              |     p  c
 *               \      /
 *                 ----
 *     3->2->1->6<-5<-4->7->8->9
 *                    d
 * temp = pdummy(1) -> next (4)
 * pdummy(1)->next(4)->next = curr(7)
 * pdummy(1)->next() = prev(6)
 * pdummy = temp(4)
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode * dummy = new ListNode(-1, head);
        ListNode * pdummy = dummy;
        ListNode * curr = head;
        ListNode * pHead = head;
        ListNode * prev = nullptr;
        while (pHead){
            int j = 0;
            pHead = curr;
            for (j = 0; j < k&&pHead; j++) {
                pHead = pHead->next;
            }
            if (pHead==nullptr && j < k){
                break;
            }

            for (int i = 0; i < k; i++) {
                ListNode * next = curr->next;
                curr->next = prev;
                prev = curr;
                curr = next;
            }

            ListNode * temp = pdummy->next;
            pdummy->next->next = curr;
            pdummy->next = prev;
            pdummy = temp;
            // 1->2->3->4->5->6->7->8->9
            // 1<-2<-3 4->5->6
            //       p c
            //
            // temp = pdummy(-1) -> next (1)
            // pdummy(-1)->next(1)->next = curr(4)
            // pdummy(-1)->next() = prev(3)
            // pdummy = temp(1)
            //  3->2->1->4<-5<-6
            //        p
        }
        return dummy->next;
    }
};
```
#LinkedList;