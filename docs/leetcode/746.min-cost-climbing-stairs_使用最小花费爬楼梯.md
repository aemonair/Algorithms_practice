#### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

难度简单

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

**输入：** cost = \[ 10, **15** ,20 \]

**输出：** 15

**解释：** 你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

**示例 2：**

**输入：** cost = \[_**1**_,100,_**1**_,1,_**1**_,100,_**1**_,_**1**_,100,_**1**_\]

**输出：** 6

**解释：** 你将从下标为 0 的台阶开始。

- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。

**提示：**

-   `2 <= cost.length <= 1000`
-   `0 <= cost[i] <= 999`

---- ----
#### 问题化简
> 如果最后一步爬了 1 个台阶，那么我们得先爬到 8，要解决的问题缩小成：从 0 或 1 爬到 8 的最小花费。
> 如果最后一步爬了 2 个台阶，那么我们得先爬到 7，要解决的问题缩小成：从 0 或 1 爬到 7 的最小花费。

>如果最后一步爬了 1 个台阶，那么我们得先爬到 i−1，要解决的问题缩小成：从 0 或 1 爬到 i−1 的最小花费。把这个最小花费加上 cost[i−1]，就得到了 dfs(i)，即 `dfs(i)=dfs(i−1)+cost[i−1]`。
 如果最后一步爬了 2 个台阶，那么我们得先爬到 i−2，要解决的问题缩小成：从 0 或 1 爬到 i−2 的最小花费。把这个最小花费加上 cost[i−2]，就得到了 dfs(i)，即 `dfs(i)=dfs(i−2)+cost[i−2]`。

> 这两种情况取最小值，就得到了从 0 或 1 爬到 i 的最小花费，即
` dfs(i)=min(dfs(i−1)+cost[i−1],dfs(i−2)+cost[i−2])`

[动态规划-灵茶山艾府](https://leetcode.cn/problems/min-cost-climbing-stairs/solutions/2569116/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-j99e/)

#### dp推导
1.  确定dp数组以及下标的含义
使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。
**dp\[i]的定义：到达第i台阶所花费的最少花费为dp\[i]**。
2.  确定递推公式
**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。
    `dp\[i - 1] 跳到 dp\[i] 需要花费 dp\[i - 1] + cost\[i - 1]`。
    `dp\[i - 2] 跳到 dp\[i] 需要花费 dp\[i - 2] + cost\[i - 2]`。
选较小的：
    `dp\[i] = min(dp\[i - 1] + cost\[i - 1], dp\[i - 2] + cost\[i - 2]);`
3.  dp数组如何初始化
dp\[0] = 0,dp\[1]=0
4.  确定遍历顺序
5. 举例推导dp数组

#### 为什么最后是 `dp[n]`？

- 题目要求我们从楼底（索引为 0）爬到楼顶（索引为 `n`）。这里的 `n` 实际上是指楼顶的位置，而不是 `cost` 数组中的最后一个元素。
- 由于我们可以从 `n-1` 或 `n-2` 跳到楼顶，所以 `dp[n]` 代表了到达楼顶的最小花费。

#### 为什么不需要初始化 `dp[0]` 和 `dp[1]`？

- 在这个实现中，`dp` 数组的大小是 `n + 1`，而 `cost` 数组的大小是 `n`。`dp[0]` 和 `dp[1]` 实际上是隐式初始化的。
- `dp[0]` 和 `dp[1]` 分别表示到达第 0 个台阶和第 1 个台阶的最小花费。因为可以从楼底直接到达第 0 个台阶和第 1 个台阶，所以这两个位置的初始花费为 0。
- 也就是说，`dp[0]` 和 `dp[1]` 默认为 0，这在循环开始前已经通过 `std::vector<int> dp(n + 1, 0);` 初始化了。

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        std::vector<int> dp(n + 1, 0);
        for (int i = 2; i <= n; ++i) {
            dp[i] = std::min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);
        }
        return dp[n];
    }
};
```

```cpp
// 版本二
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = 0;
        int dp1 = 0;
        for (int i = 2; i <= cost.size(); i++) {
            int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);
            dp0 = dp1; // 记录一下前两位
            dp1 = dpi;
        }
        return dp1;
    }
};
```
#DynamicProgramming;
