[201. 数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

中等

给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right`端点）。

**示例 1：**

**输入：** left = 5, right = 7  
**输出：** 4  

**示例 2：**

**输入：** left = 0, right = 0  
**输出：** 0  

**示例 3：**

**输入：** left = 1, right = 2147483647  
**输出：** 0  

**提示：**

- `0 <= left <= right <= 2³¹ - 1`
---- ----
比如示例1中的5和7,left=5和right=7：
二进制是101和111。
它们右移1次变成10和11，不相等。
再右移一次变成1和1，相等了，移动了2次。
所以结果是1左移2位，得到4。

第一次循环，5>>1=2（10），7>>1=3（11），不等。shift=1。
第二次循环，2>>1=1，3>>1=1，相等。shift=2。
此时left=1，返回1<<2=4。

另一个例子，比如left=6（110）和right=7（111）。
移动一次得到3和3，此时返回3<<1=6。而6&7=6。

----

1. **公共前缀定位**：通过不断右移两个数直到它们相等，找到它们的公共前缀。右移的次数即为需要补零的位数。
2. **结果构造**：将公共前缀左移相应的位数，得到最终结果。

该方法的时间复杂度为 O(1)，因为最多进行31次右移操作（整型数位数为31位）。
空间复杂度为 O(1)。
```cpp
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int shift = 0;
        while (left != right) {
            left >>= 1;
            right >>= 1;
            shift += 1;
        }
        return left << shift;
    }
};
```

----

区间内所有数字按位与的结果 = left和right的二进制公共前缀 + 后续所有位补零

```cpp
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        // 0 的二进制长度为 0
        int m = left == right ? 0 : 32 - __builtin_clz(left ^ right);
        return left & ~((1u << m) - 1);
    }
};
```
[找前缀相同的长度然后取反 - 灵茶山艾府](https://leetcode.cn/problems/bitwise-and-of-numbers-range/solutions/538550/golang-yi-xing-suan-fa-by-endlesscheng-iw6y/)

例如：
```cpp
left  = 5 (0101)
right = 7 (0111)
公共前缀是01，后续两位补零得到0100 = 4
```

1. **计算差异位**：
```cpp
    int m = left == right ? 0 : 32 - __builtin_clz(left ^ right);
```
    - `left ^ right` 得到所有不同二进制位的位置
    - `__builtin_clz(x)` 计算x的二进制前导零个数（clz=count leading zeros）
    - `32 - __builtin_clz(x)` 得到最高有效位的位置（例如：x=8(1000)时得到4）
        
2. **构造掩码**：
```cpp
    return left & ~((1u << m) - 1);
```
    - `(1u << m) - 1` 生成低m位全1的掩码（例如m=3时得到0b111）
    - `~` 取反后得到高32-m位全1，低m位全0的掩码（例如：0b11111111111111111111111111111000）
    - 最后与left按位与，保留公共前缀，清零差异位

以 left=5(0101), right=7(0111) 为例：
1. `left ^ right = 0010`（二进制差异位）
2. `__builtin_clz(0010) = 29`（前导29个零）
3. `m = 32 - 29 = 3`（最高差异位在第3位）
4. `(1u << 3) - 1 = 0b0111`
5. `~0b0111 = 0b11111111111111111111111111111000`
6. `left & mask = 0101 & 11111111111111111111111111111000 = 0100 = 4`

----
```cpp
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        if (left == right) return left;
        uint32_t xor_val = left ^ right;
        int leading_zeros = count_leading_zeros(xor_val);
        int m = 32 - leading_zeros;
        return left & ~((1u << m) - 1);
    }

private:
    // 计算 32 位无符号整数二进制的前导零数量
    int count_leading_zeros(uint32_t n) {
        if (n == 0) return 32; // 特殊处理 n=0
        int count = 0;
        // 通过二分法逐级缩小范围
        if ((n & 0xFFFF0000) == 0) { count += 16; n <<= 16; }
        if ((n & 0xFF000000) == 0) { count += 8; n <<= 8; }
        if ((n & 0xF0000000) == 0) { count += 4; n <<= 4; }
        if ((n & 0xC0000000) == 0) { count += 2; n <<= 2; }
        if ((n & 0x80000000) == 0) { count += 1; }
        return count;
    }
};
```

`count_leading_zeros`
1. **处理全零**：若输入 `n=0`，直接返回 32。
2. **二分查找**：
    - **步骤 1**：检查高 16 位是否有 1。若无，则前导零至少 16 位，将 `n` 左移 16 位。
    - **步骤 2**：检查剩余的高 8 位，依此类推，逐步缩小范围。
    - **步骤 3~5**：分别处理 4 位、2 位、1 位的情况，最终确定前导零总数。

----
**1. 掩码的作用**

这个掩码的作用是 **将二进制数的低 `m` 位清零，保留高 `32-m` 位**。  
假设 `m=3`（表示需要清零的最低 3 位），掩码的构造过程如下：

|步骤|表达式|二进制表示（32位）|说明|
|---|---|---|---|
|1|`1u << 3`|`00000000000000000000000000001000`|将 1 左移 3 位得到 `8`|
|2|`(1u << 3) - 1`|`00000000000000000000000000000111`|减 1 得到低 3 位全 1 的掩码|
|3|`~((1u << 3)-1)`|`11111111111111111111111111111000`|取反后得到高 29 位全 1，低 3 位全 0 的掩码|

最终掩码会保留原数字的高 `32-m` 位，低 `m` 位清零。
**2. 为什么用 `1u`（无符号整型）？**

- **避免符号扩展问题**：  
    如果用有符号 `int`（例如 `1 << m`），当 `m >= 31` 时（在 32 位系统中），符号位会被污染，导致结果为负数。  
    例如：`1 << 31` 在 `int` 类型下会变成 `-2147483648`（二进制 `10000000000000000000000000000000`），导致后续运算错误。
    
- **确保逻辑正确性**：  
    使用无符号 `1u` 可以保证左移操作是纯逻辑移位（高位补 0），而非算术移位（高位补符号位）。  
    例如：`1u << 31` 会正确得到 `2147483648`（二进制 `10000000000000000000000000000000`）。

#top-interview-150; #bit; 