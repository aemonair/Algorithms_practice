#### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

难度中等

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

**输入：** s = "bbbab"
**输出：** 4
**解释：** 一个可能的最长回文子序列为 "bbbb" 。

**示例 2：**

**输入：** s = "cbbd"
**输出：** 2
**解释：** 一个可能的最长回文子序列为 "bb" 。

**提示：**

-   `1 <= s.length <= 1000`
-   `s` 仅由小写英文字母组成

---- ----
#### DP动态规划

`dp[i][j]` 表示 `s` 的第 `i` 个字符到第 `j` 个字符组成的子串中，最长的回文序列长度是多少。

0. 假如已知`dp[i+1][j-1]`如何获取 `dp[i][j]`？
```
dp[i+1][j-1] = 3
dp[i][j] = ?
```

| i   | i+1 |     |     |     | j-1 | j   |
| --- | --- | --- | --- | --- | --- | --- |
| ?   | *b* | x   | *a* | *b* | y   | ?   |

1. 如果 `s` 的第 `i` 个字符和第 `j` 个字符相同的话，
`dp[i][j] = dp[i + 1][j - 1] + 2`
```
array[i] == array[j]
  dp[i][j] = dp[i+1][j-1] + 2 = 3 +2 =5
```

| i   | i+1 |     |     |     | j-1 | j   |
| --- | --- | --- | --- | --- | --- | --- |
| c   | *b* | x   | *a* | *b* | y   | c   |

2. 如果 `s` 的第 `i` 个字符和第 `j` 个字符不同的话
```
array[i] != array[j]
  dp[i][j] = max( dp[i][j-1], dp[i+1][j] )
```

| i   | i+1 |     |     |     | j-1 | j   |
| --- | --- | --- | --- | --- | --- | --- |
| a   | *b* | x   | *a* | *b* | y   | b   |

[子序列问题通用思路|最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/solutions/67456/zi-xu-lie-wen-ti-tong-yong-si-lu-zui-chang-hui-wen/)

----

|     | j-1          | j         | j + 1      |
| --- | ------------ | --------- | ---------- |
| i-1 | (i-1 ,j-1)   | (i-1 ,j)  | (i-1, j+1) |
| i   | (i   ,j-1) ⇢ | (i   ,j)  | (i  , j+1) |
| i+1 | (i+1 ,j-1)↗︎ | (i+1 ,j)⇡ | (i+1, j+1) |
dp从下往上，所以i会从大到小递归；

----
#### 二维DP 
```cpp
    int longestPalindromeSubseq(std::string s)  
    {                                 
        int size = s.size();          
        std::vector<std::vector<int>> dp(size, std::vector<int>(size, 0));
        for (int i = 0; i < size; ++i) {
            dp[i][i] = 1;             
        }                             
        // dp[i][j]                   
        // == dp[i+1][j-1] + 2        
        // != dp[i+1][j] , dp[i][j-1]
        for (int i = size - 2; i >= 0 ; i--) {                                   
            for (int j = i + 1; j < size; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = 2 + dp[i+1][j-1];
                } else {              
                    dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);
                }                     
            }                         
        }                             
        return dp[0][size - 1];       
    }
```
##### 代码解释
1. **初始化**：
    
    - `size` 存储字符串 `s` 的长度。
    - `dp` 是一个二维动态规划数组，`dp[i][j]` 表示字符串 `s` 从索引 `i` 到索引 `j`的最长回文子序列的长度。初始时，所有元素都被设为 0。
2. **动态规划过程**：
    
    - 外层循环从 `i = size-2` 到 `i = 0`，即从字符串的倒数第二个字符开始，逐步向前遍历。
    - 内层循环从 `j = i+1` 到 `j = size-1`，即从当前字符的下一个字符开始，逐步向后遍历。
3. **状态转移**：
    
    - 对于每个 `i` 和 `j`，有以下两种情况：
        - 如果 `s[i] == s[j]`，即当前字符 `s[i]` 和 `s[j]` 相同，则 `dp[i][j]`的值等于 `dp[i+1][j-1] + 2`。这是因为 `s[i]` 和 `s[j]` 可以构成一个长度为 2 的回文子序列，并且加上中间部分的最长回文子序列。
        - 如果 `s[i] != s[j]`，即当前字符 `s[i]` 和 `s[j]` 不相同，则 `dp[i][j]`的值等于 `max(dp[i+1][j], dp[i][j-1])`。这是因为我们需要在 `s[i+1]`到 `s[j]` 或 `s[i]` 到 `s[j-1]` 之间选择一个较长的回文子序列。
4. **边界条件**：
    
    - `dp[i][i] = 1`，表示单个字符的最长回文子序列长度为 1。
5. **返回结果**：
    
    - 最后返回 `dp[0][size-1]`，即整个字符串 `s` 的最长回文子序列的长度。

##### 下标解释

- **外层循环 `i`**：
    
    - `i` 从 `size-2` 到 `0`，表示从字符串的倒数第二个字符开始，逐步向前遍历。
    - `dp[i][i] = 1`，表示单个字符的最长回文子序列长度为 1。
- **内层循环 `j`**：
    
    - `j` 从 `i+1` 到 `size-1`，表示从当前字符的下一个字符开始，逐步向后遍历。
    - `dp[i][j]` 表示字符串 `s` 从索引 `i` 到索引 `j` 的最长回文子序列的长度。


> `dp [i] [j] `只与它左边的`dp[i][j-1] `下边`dp[i+1][j]`以及左下角`dp[i+1][j-1]`有关。每次遍历的时候是保持j不变，`i`从`j-1`从大遍历到小。
> 如果用一维优化二维得话，`dp[i+1][j]`就是新的`dp[i+1],dp[i][j-1]`就是旧的`dp[i]`，这些用一维都很好处理，关键是`dp[i+1][j-1]`是旧的`dp`
> `dp[i+1]`这在上一次计算中已经被覆盖了，所以可以用一个中间值把他保存下来，就可以做到一维dp了

#### 一维DP
```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<int> dp(s.size(), 0);
        for (int j = 0; j < s.size(); ++j) {
            // 因为一个点[i,j]的状态只取决于其 [左, 下, 左下] 三个位置的状态
            // j表示列,  要从左往右枚举, 这样在计算某个点时, 能保证其左侧点是当前行的状态(已更新的状态)
            dp[j] = 1;
            int old = 0;
            int temp = 0;
            for (int i = j - 1; i >= 0; --i) {
                // i 表示行, 从下往上枚举
                // 暂存这个值, 这个值是下一次更新时的左下角
                temp = dp[i];
               // 若 s[i] == s[j], 则取 左下角 + 2, 否则, 取左或下中的较大者  d[i] 是 左, d[i + 1] 是 下
                dp[i] = (s[i] != s[j]) ? max(dp[i], dp[i + 1]) : old + 2;
                old = temp;
            }
        }
        return dp[0]; // 最后的dp[0] 相当于 dp[0][n - 1], 因为j是从0开始枚举, 最后一次更新完后, j 其实是n - 1
    }
};
```

> 求ｓ和ｓ的逆序的最长公共子序列的。


#dynamic-programming; #string;
