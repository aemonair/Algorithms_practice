[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

中等

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]`的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

**示例 1：**

**输入：** s = "ababcbacadefegdehijhklij"  
**输出：**[9,7,8]  
**解释：**  
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。  
每个字母最多出现在一个片段中。  
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。   

**示例 2：**

**输入：** s = "eccbbbbdec"  
**输出：**[10]  

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成
---- ----
### 合并区间：

#### 合并区间只关注结束
1. 遍历 s，计算字母 c 在 s 中的最后出现的下标 last[c]。
2. 初始化当前正在合并的区间左右端点 start=0, end=0。
3. 再次遍历 s，由于当前区间必须包含所有 s[i]，所以用 `last[s[i]]` 更新区间右端点 end 的最大值。
4. 如果发现 end=i，那么当前区间合并完毕，把区间长度 `end−start+1` 加入答案。然后更新 start=i+1 作为下一个区间的左端点。
5. 遍历完毕，返回答案。
```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int n = s.length();
        int last[26];
        for (int i = 0; i < n; i++) {
            last[s[i] - 'a'] = i; // 每个字母最后出现的下标
        }

        vector<int> ans;
        int start = 0, end = 0;
        for (int i = 0; i < n; i++) {
            end = max(end, last[s[i] - 'a']); // 更新当前区间右端点的最大值
            if (end == i) { // 当前区间合并完毕
                ans.push_back(end - start + 1); // 区间长度加入答案
                start = i + 1; // 下一个区间的左端点
            }
        }
        return ans;
    }
};
```
[合并区间，简洁写法 - 灵茶山艾府](https://leetcode.cn/problems/partition-labels/solutions/2806706/ben-zhi-shi-he-bing-qu-jian-jian-ji-xie-ygsn8/)

#### 原先最基础做法：
记录相同字母的下标，作为区间，然后进行区间合并，查看有多少个区间，区间的长度即为结果；

例如：
```
s = "ababcbacadefegdehijhklij"
a0~8 b1~5 c4~7 d9~14 e10~15 f11~11 g13~13 h16~19 i17~22 j18~23 k20~20 l21~21 
pair排序后进行区间合并得到：
0~8, 9~15, 16~23,
```

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int n = s.size();
        vector<pair<int,int>> vec(26, {-1,-1});
        for (int i = 0; i < n; ++i) {
            int index = s[i]-'a';
            if (vec[index].first == -1) {
                vec[index].first = i;
                vec[index].second = i;
            } else {
                vec[index].second=i;
            }
        }

        sort(vec.begin(), vec.end(), [&](pair<int,int> &a, pair<int,int> &b){
            // return a.second < b.second;
            return a.first < b.first;
        });
  
        //  2~3
        // 1~~4
        //       5-6
        vector< pair<int,int>> res;
        for (auto x: vec) {
            if (x.first == -1) continue;
            if (!res.empty() && res.back().second >= x.first) {
                res.back().first = min(res.back().first, x.first);
                res.back().second = max(res.back().second, x.second);
            } else {
                res.emplace_back(x);
            }
        }
        // cout << "res:";
        vector<int> ans(res.size());
        int i = 0;
        for (auto x: res) {
            // cout << x.first << "~" << x.second << ", ";
            // ans.push_back(x.second-x.first+1);
            ans[i] = (x.second-x.first+1);
            i++;
        }
        return ans;
        return {};
    }
};
```
#top-100-liked; #greedy;