[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

中等

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 _该数组中和为 `k` 的子数组的个数_ 。

子数组是数组中元素的连续非空序列。

**示例 1：**

**输入：** nums = [1,1,1], k = 2  
**输出：** 2

**示例 2：**

**输入：** nums = [1,2,3], k = 3  
**输出：** 2

**提示：**

- `1 <= nums.length <= 2 * 10⁴`
- `-1000 <= nums[i] <= 1000`
- `-10⁷ <= k <= 10⁷`

---- ----

方法1: 枚举
```cpp
    int subarraySum(std::vector<int>& nums, int k)
    {
        int count = 0;
        for (int i=0; i < nums.size(); ++i) {
            int sum = 0;
            for (int j =i; j >= 0; --j) {
                sum += nums[j];
                if (sum ==k) {
                    count++;
                }
            }
        }
        return count;
    }
```


假设输入数组 `nums = [1, 2, 3]` 和目标值 `k = 3`：  
i从0开始递增；j从i开始递减；  
每次向前增加nums[j]然后判断 sum是否与k相等；
```
sum:0 + nums[0]:1 1
sum:0 + nums[1]:2 2 sum:2 + nums[0]:1 3
sum:0 + nums[2]:3 3 sum:3 + nums[1]:2 5 sum:5 + nums[0]:1 6
```
1. `start = 0`:
    - `end = 0`: 子数组 `[1]`，和为 `1`，不满足条件
2. `start = 1`:
    - `end = 1`: 子数组 `[2]`，和为 `2`，不满足条件
    - `end = 0`: 子数组 `[2, 1]`，和为 `3`，满足条件，`count = 2`
3. `start = 2`:
    - `end = 2`: 子数组 `[3]`，和为 `3`，满足条件，`count = 3`
    - `end = 1`: 子数组 `[3, 2]`，和为 `5`，不满足条件
    - `end = 0`: 子数组 `[3, 2, 1]`，和为 `6`，不满足条件
最终返回 `count = 3`。

#### 方法2:前缀和
```cpp
    int subarraySum(std::vector<int>& nums, int k)
    {
        int size = nums.size();
        std::unordered_map<int, int> hash;
        int sum = 0;
        std::vector<int> pre(size+1, 0);
        for (int i = 0; i < size; ++i) {
            pre[i+1] = pre[i] + nums[i];
        }

        for (auto &x: pre) {
            if (hash.count( x - k) > 0) {
                std::cout <<  " " <<hash[x-k] << std::endl;
                sum += hash[x-k];
            }
            ++hash[x] ;
        }
        return sum;
    }
```
##### 2.1 前缀和是什么？
> 即 pre[1] 用来保存包含第一个元素(nums[0])的一个和；  
> 即 pre[2] 用来保存包含第一个第二个元素(nums[0]+nums[1])的一个和；

```
pre[0]=0, 
pre[i]=nums[0]+nums[1]+⋯+nums[i-1]
pre[i+1]=nums[0]+nums[1]+⋯+nums[i]

即 pre[i] = pre[i-1]+nums[i-1]
```
pre[i]保存 [0...i-1]下标的和；  
对于数组中的任何位置 i，前缀和 pre[i] 是数组中从第一个元素到第 i 个元素的总和。

需要求子数组和 ；
```
|0 |1 |2 |i-1| i | i+1 | .. |j-1 | j |

   pre [i]
|__+__+__+___|
             pre [j]
|__+__+__+___+___+_____+ .. +____|

                    pre [j+1]
|__+__+__+___+___+_____+ .. +____+____|

               pre[j]-pre[i] == [i, j-1]
             |___+_____+ .. +____|

               pre[j+1]-pre[i] == [i, j]
             |___+_____+ .. +____+____|

```
比如 [i..j] 这个子数组和为 k,  
pre[i]对应0 ～ i-1 之前的子数组和；  
pre[j]对应0 ～ j-1 之前的子数组和；  
这意味着如果你想知道从元素 i 到 j 的子数组的和，你可以用 pre[j+1] - pre[i] 来计算。

`pre[j]−pre[i]` 即 下标从 i 到 j−1 的非空连续子数组的元素和等于 k，即  
`pre[j]−pre[i]==k (i<j)`

枚举 j，上式变成 pre[i]=pre[j]−k  
根据上式，计算 s[i] 的个数，等价于计算 s[j]−k 的个数。

##### 2.2 使用哈希表的原因
1. **记录前缀和出现次数**：
    - 我们需要记录每个前缀和出现的次数。这是因为前缀和可能重复出现，而我们需要统计所有符合条件的子数组。
2. **查找目标前缀和**：
    - 对于当前的前缀和 `pre[j]`，我们需要找到是否存在某个前缀和 `pre[i]` 使得 `pre[j] - pre[i] = k`。
    - 这意味着我们需要找到 `pre[i] = pre[j] - k`。

在遍历 pre[j] 的同时，用一个哈希表 map 统计 pre[j] 的个数。  
那么枚举到 pre[j] 时，从哈希表中就可以找到有 map[pre[j]−k] 个 pre[i]，即为元素和等于 k 的子数组个数，加入答案。

假设 k = 7，并且我们当前的累积和 pre 是 10，如果在 map 中 3（即 10 - 7）出现了两次，这表示存在两个不同的起始点，使得从那些起始点到当前点的子数组之和是 7。

##### 2.3 例子：
以 nums=[1,1,−1,1,−1], k=1 为例，其前缀和 s=[0,1,2,1,2,1]。

| j   | nums[j] | pre[j] | pre[j]−k                                          | 子数组个数 |                 | map                 |     |
| --- | ------- | ------ | ------------------------------------------------- | ----- | --------------- | ------------------- | --- |
| 0   | 1       | 0      | −1 不存在                                            | 0     | pre的0出现1次，存入map | (0,1)               | +0  |
| 1   | 1       | 1      | 0 在map中存在，表示map中有个0 + k(1) 出现1次，使得那1个起始点到当前子数组和是1 | 1     | pre的1存入map      | (1,1),(0,1)         | +1  |
| 2   | -1      | 2      | 1 在map中存在，表示从map中的那个起始点到当前的2有相差为k(1)的子数组和         | 1     | pre的2 存入map     | (2,1), (1,1), (0,1) | +1  |
| 3   | 1       | 1      | 0 在map中存在，表示从map中的0可以到达当前的子数组和为k                  | 1     | pre的1的value++   | (2,1), (1,2), (0,1) | +1  |
| 4   | -1      | 2      | 1 在map中存在，且为2，表示有两个子数组和都能到2，然后再子数组和的k             | 2     | pre的2的value++   | (2,2), (1,2), (0,1) | +2  |
| 5   |         | 1      | 0 在map中存在，且为1，表示有一个存在的子数组                         | 1     | pre的1的value++   | (2,2), (1,3), (0,1) | +1  |
nums=[1,1,1] ,k=2
pres=[0,1,2,3]
- `i = 0`:
    - `prefix_sum = 0 `
    - `target = 0 - 2 = -2` （map中不存在）
    - `count_map = {0: 1}` 存入map{0:1}
- `i = 1`:
    - `prefix_sum = 1 `
    - `target = 1 - 2 = -1` （map中不存在）
    - `count_map = {0: 1, 1: 1}` 存入map{1:1}
- `i = 2`:
    - `prefix_sum = 2 `
    - `target = 3 - 2 = 1` （map中存在）
    - `count += count_map[1] = 1`
    - `count_map = {0: 1, 1: 1, 2: 1}`存入map{2:1}
- `i = 2`:
    - `prefix_sum = 3 `
    - `target = 3 - 2 = 1` （map中存在）
    - `count += count_map[1] = 1`
    - `count_map = {0: 1, 1: 2, 2: 1, 3: 1}`存入map{3:1}

```
nums=[1,2,3,-3] k =3
pre=[0,1,3,6,3]

0
0-3 = -3 ；map不存在
插入 {0:1}

1
1-3 = -2； map不存在
插入 {1:1}得到
{0:1},{1:1}

3
3-3=0； map存在0对应1，
表示 能从map对应的0 到当前的3，中间子数组和为k；对应子数组[1,2]
插入{3，1} 得到：
{0:1},{1:1},{3:1}

6
6-3=3; map中存在3，对应 [3]
表示能从 那个3 到当前的6，中间子数组和为k；对应子数组[1,2]
插入{6:1}得到
{0:1},{1:1},{3:1},{6:1}

3
3-3=0； map中存在已有的 0，对应1个；
表示能从那个前缀0（即3的位置）到达当前的-3使得中间子数组和为k；对应子数组 [1,2,3，-3]
{0:1},{1:1},{3:2},{6:1},
```

#PrefixSum;
