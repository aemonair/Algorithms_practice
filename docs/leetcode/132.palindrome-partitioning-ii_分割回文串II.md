[132. åˆ†å‰²å›æ–‡ä¸² II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

å›°éš¾

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²Â `s`ï¼Œè¯·ä½ å°†Â `s`Â åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²ã€‚

è¿”å›ç¬¦åˆè¦æ±‚çš„Â **æœ€å°‘åˆ†å‰²æ¬¡æ•°**Â ã€‚

**ç¤ºä¾‹ 1ï¼š**

**è¾“å…¥ï¼š** s = "aab"  
**è¾“å‡ºï¼š** 1  
**è§£é‡Šï¼š** åªéœ€ä¸€æ¬¡åˆ†å‰²å°±å¯å°†Â _s_ åˆ†å‰²æˆ ["aa","b"] è¿™æ ·ä¸¤ä¸ªå›æ–‡å­ä¸²ã€‚

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** s = "a"  
**è¾“å‡ºï¼š** 0

**ç¤ºä¾‹ 3ï¼š**

**è¾“å…¥ï¼š** s = "ab"  
**è¾“å‡ºï¼š** 1

**æç¤ºï¼š**

- `1 <= s.length <= 2000`
- `s`Â ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

---- ----

```cpp
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector is_pali(n, vector<bool>(n, true));
        for (int i = n-2; i >=0; i--) {
            for (int j= i+1; j < n; ++j) {
                is_pali[i][j] = is_pali[i+1][j-1] && (s[i]==s[j]);
            }
        }
        vector<int> dp(n+1, INT_MAX);
        for (int i = 0; i < n; ++i) {
            if (is_pali[0][i]) {
                dp[i] = 0; 
                continue;
            }
            for (int l = 1; l <= i; ++l) {
                if (is_pali[l][i]) {
                    dp[i] = min(dp[i], dp[l-1] + 1);
                }
            }
        }
        return dp[n-1];
    }
};
```
[æ•™ä½ ä¸€æ­¥æ­¥æ€è€ƒ DPï¼šä»è®°å¿†åŒ–æœç´¢åˆ°é€’æ¨ - çµèŒ¶å±±è‰¾åºœ](https://leetcode.cn/problems/palindrome-partitioning-ii/solutions/3588633/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-bnlb/)

### 1.é¦–å…ˆï¼Œæ˜¯ è·å–æ˜¯å¦ä¸º å›æ–‡ä¸²çš„æ–¹æ³•ï¼›

#### 1.1 å›æ–‡ä¸²åˆ¤æ–­
å¦‚ä½•åˆ¤æ–­å­ä¸² `s[l]` åˆ° `s[r]` æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Ÿ
åˆ†ç±»è®¨è®ºï¼š
- å¦‚æœ `s[l]â‰ s[r]`ï¼Œé‚£ä¹ˆå­ä¸²è‚¯å®šä¸æ˜¯å›æ–‡ä¸²ã€‚
- å¦‚æœ `s[l]=s[r]`ï¼Œé‚£ä¹ˆé—®é¢˜å˜æˆï¼š`s[l+1]` åˆ° `s[râˆ’1]` æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Ÿè¿™æ˜¯ä¸ªå’ŒåŸé—®é¢˜ç›¸ä¼¼çš„ã€è§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œä¹Ÿå¯ä»¥ç”¨é€’å½’è§£å†³ã€‚

```cpp
    vector pal_memo(n, vector<int>(n, -1)); // -1 è¡¨ç¤ºæ²¡æœ‰è®¡ç®—è¿‡
    auto is_palindrome = [&](this auto&& is_palindrome, int l, int r) -> bool {
        if (l >= r) {
            return true;
        }
        int& res = pal_memo[l][r]; // æ³¨æ„è¿™é‡Œæ˜¯å¼•ç”¨
        if (res != -1) { // ä¹‹å‰è®¡ç®—è¿‡
            return res;
        }
        return res = s[l] == s[r] && is_palindrome(l + 1, r - 1);
    };
```

#### 1.2 é€’å½’åˆ°é€’æ¨ï¼š 
`is_palindrome[l][r]` çš„å®šä¹‰å’Œ `is_palindrome(l,r)` çš„å®šä¹‰æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œ  
éƒ½è¡¨ç¤ºå­ä¸² `s[l]` åˆ° `s[r]` æ˜¯å¦ä¸ºå›æ–‡ä¸²ã€‚

ç›¸åº”çš„é€’æ¨å¼ï¼ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼‰ä¹Ÿå’Œ dfs ä¸€æ ·ï¼š  

å¦‚æœ `s[l]â‰ s[r]`ï¼Œé‚£ä¹ˆ `is_palindrome[l][r]=false`ã€‚  
å¦‚æœ `s[l]=s[r]`ï¼Œé‚£ä¹ˆ `is_palindrome[l][r]=isPalindrome[l+1][râˆ’1]`ã€‚  
åˆå§‹å€¼ `is_palindrome[l][l]=is_palindrome[l][lâˆ’1]=true`ï¼Œ  
ç¿»è¯‘è‡ªé€’å½’è¾¹ç•Œ `is_palindrome(l,l)=is_palindrome(l,lâˆ’1)=true`ã€‚

```cpp
    // is_palindrome[l][r] è¡¨ç¤º s[l] åˆ° s[r] æ˜¯å¦ä¸ºå›æ–‡ä¸²
    vector is_palindrome(n, vector<int>(n, true));
    for (int l = n - 2; l >= 0; l--) {
        for (int r = l + 1; r < n; r++) {
            is_palindrome[l][r] = s[l] == s[r] && is_palindrome[l + 1][r - 1];
        }
    }
```

### 2.å…³äºå¦‚ä½•æ¨å¯¼ åˆ†å‰²å›æ–‡ä¸²çš„é€»è¾‘

#### 2.1 ä¾‹å­ğŸŒ°
ä¾‹å¦‚ `s=aabb`ï¼Œæˆ‘ä»¬è¦è§£å†³çš„é—®é¢˜ï¼ˆåŸé—®é¢˜ï¼‰æ˜¯ï¼š
- æŠŠ `s=aabb` åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²çš„æœ€å°‘åˆ†å‰²æ¬¡æ•°ã€‚
æšä¸¾åˆ†å‰²å‡ºçš„æœ€å³è¾¹é‚£æ®µå­ä¸²çš„é•¿åº¦ï¼ˆæˆ–è€…å·¦ç«¯ç‚¹ï¼‰ï¼š
- åˆ†å‰²å‡ºå­ä¸² bï¼Œè¿™æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆéœ€è¦è§£å†³çš„å­é—®é¢˜ä¸ºï¼šæŠŠ aab åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²çš„æœ€å°‘åˆ†å‰²æ¬¡æ•°ã€‚
- åˆ†å‰²å‡ºå­ä¸² bbï¼Œè¿™æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆéœ€è¦è§£å†³çš„å­é—®é¢˜ä¸ºï¼šæŠŠ aa åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²çš„æœ€å°‘åˆ†å‰²æ¬¡æ•°ã€‚
- åˆ†å‰²å‡ºå­ä¸² abbï¼Œè¿™ä¸æ˜¯å›æ–‡ä¸²ã€‚
- åˆ†å‰²å‡ºå­ä¸² aabbï¼Œè¿™ä¸æ˜¯å›æ–‡ä¸²ã€‚

#### 2.2 çŠ¶æ€ï¼š
ç”±äºæ¯ä¸ªå­é—®é¢˜è®¡ç®—çš„éƒ½æ˜¯ s çš„å‰ç¼€ `s[0]` åˆ° `s[r]`ï¼Œå®šä¹‰ dfs(r) è¡¨ç¤ºæŠŠå‰ç¼€ `s[0]` åˆ° `s[r]` åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²çš„æœ€å°‘åˆ†å‰²æ¬¡æ•°ã€‚

æšä¸¾åˆ†å‰²å‡ºçš„æœ€å³è¾¹é‚£æ®µå­ä¸²çš„å·¦ç«¯ç‚¹ lï¼š
```
[0..........r] dfs(r)

[0.......l][r] dfs(r)
[0......l.][r] 
[0.....l..][r] 
```
å¦‚æœ `s[l]` åˆ° `s[r]` æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆåœ¨ `lâˆ’1` å’Œ `l` ä¹‹é—´åˆ‡ä¸€åˆ€ï¼Œæ¥ä¸‹æ¥éœ€è¦è§£å†³çš„å­é—®é¢˜ä¸ºï¼š  
æŠŠå‰ç¼€ `s[0]` åˆ° `s[lâˆ’1]` åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²çš„æœ€å°‘åˆ†å‰²æ¬¡æ•°ï¼Œå³ `dfs(lâˆ’1)`ã€‚  
æ‰€æœ‰æƒ…å†µå–æœ€å°å€¼ï¼Œå³
```
         r
dfs(r)= min dfs(lâˆ’1)+1
        l=1
```
å…¶ä¸­ +1 è¡¨ç¤ºåœ¨ `lâˆ’1` å’Œ `l` ä¹‹é—´åˆ‡ä¸€åˆ€ï¼Œè¿™ç®—ä½œ 1 æ¬¡åˆ†å‰²æ¬¡æ•°ã€‚  
é€’å½’è¾¹ç•Œï¼šå¦‚æœ `s[0]` åˆ° `s[r]` æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆæ— éœ€åˆ†å‰²ï¼Œç›´æ¥è¿”å› 0ã€‚  
é€’å½’å…¥å£ï¼šdfs(nâˆ’1)ï¼Œè¿™æ˜¯åŸé—®é¢˜ï¼Œä¹Ÿæ˜¯ç­”æ¡ˆã€‚

è§£é‡Šï¼š  
å¤§æ¦‚å°±æ˜¯è¯´ï¼Œæ˜¯è¦è®¡ç®—ä»¥`0ï½r`çš„èŒƒå›´å†…çš„`dfs(r)`ï¼Œ  
- å¦‚æœ `0~r`æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆä¸ç”¨åˆ†å‰²ï¼Œå¯ä»¥ç›´æ¥è¿”å›0ï¼›
- éå†`l`:
    - å¦‚æœ`s[l~r]`æ˜¯å›æ–‡ä¸²:
    - é‚£ä¹ˆå‰©ä¸‹çš„`s[0~l]`å›æ–‡ä¸²åˆ†å‰²æ•°é‡ï¼Œå¯ä»¥é€šè¿‡`dfs(l)`æ¨å¯¼ï¼š
    - å¦‚æœ `dfs(l)`æœ‰ç»“æœï¼Œé‚£ä¹ˆ+1å°±æ˜¯åŠ ä¸Š`s[l~r]`çš„åˆ†å‰²ç»“æœï¼Œå¾—åˆ°åˆ†å‰²`0~r`çš„ç»“æœ;

é€’å½’ï¼š
```cpp
        vector<int> dfs_memo(n, INT_MAX); // INT_MAX è¡¨ç¤ºæ²¡æœ‰è®¡ç®—è¿‡
        auto dfs = [&](this auto&& dfs, int r) -> int {
            if (is_palindrome(0, r)) { // å·²æ˜¯å›æ–‡ä¸²ï¼Œæ— éœ€åˆ†å‰²
                return 0;
            }
            int& res = dfs_memo[r]; // æ³¨æ„è¿™é‡Œæ˜¯å¼•ç”¨
            if (res != INT_MAX) { // ä¹‹å‰è®¡ç®—è¿‡
                return res;
            }
            for (int l = 1; l <= r; l++) { // æšä¸¾åˆ†å‰²ä½ç½®
                if (is_palindrome(l, r)) {
                    res = min(res, dfs(l - 1) + 1); // åœ¨ l-1 å’Œ l ä¹‹é—´åˆ‡ä¸€åˆ€
                }
            }
            return res;
        };
```

é€’æ¨ï¼š
```cpp
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector check(n, vector<bool>(n, true));
        for (int i = n-1; i>=0; i--) {
            for (int j = i+1; j <= n; j++) {
                check[i][j] = s[i]==s[j] && check[i+1][j-1];
            }
        }
        vector<int> dp(n);
        for (int r = 0; r < n; ++r) {
            if (check[0][r]) {
                continue;
            }
            int res = INT_MAX;
            for (int l = 1; l <= r; l++) {
                if (check[l][r]) {
                    res = min(res, dp[l-1]+1);
                }
            }
            dp[r] = res;
        }
        return dp[n-1];
    }
};
```

#DynamicProgramming;