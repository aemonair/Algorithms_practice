[358.K距离间隔重排字符串](https://leetcode.cn/problems/rearrange-string-k-distance-apart/description/)

题目描述:

给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。

所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 ""。

示例 1：

```text
输入: s = "aabbcc", k = 3
输出: "abcabc" 
解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。
```

示例 2:

```text
输入: s = "aaabc", k = 3
输出: "" 
解释: 没有办法找到可能的重排结果。
```

示例 3:

```text
输入: s = "aaadbbcc", k = 2
输出: "abacabcd"
解释: 相同的字母在新的字符串中间隔至少 2 个单位距离。
```

---- ----

首先通过hashmap和priority_queue得到不同字符的出现次数及排列顺序；
然后，因为需要间隔k个单位，不能放回priority_queue，可以先放入vector/queue/deque等容器，待k个条件满足后重新放回priority_queue中；

```cpp
    std::string rearrangeString(std::string s, int k)
    {
        std::unordered_map<char, int> umap;
        for (auto &c: s) {
            umap[c]++;
        }
        std::priority_queue<std::pair<int,char>> max_heap;
        for (auto [val,cnt] : umap) {
            max_heap.push({cnt, val});
        }
        std::queue<std::pair<int, char>> cooldown_queue;
        std::string result;

        while (!max_heap.empty()) {
            auto [freq, ch] = max_heap.top();
            max_heap.pop();
            // Append the current character to the result string
            result += ch;
            // Decrease the frequency and add character to cooldown queue
            cooldown_queue.push({freq - 1, ch});

            // If cooldown queue size reached k, release the front character from cooldown
            if (cooldown_queue.size() >= k) {
                auto [freq_count, front_char] = cooldown_queue.front();
                cooldown_queue.pop();

                // If the character still has remaining counts, add it back to the max heap
                if (freq_count > 0) {
                    max_heap.push({freq_count, front_char});
                }
            }
        }

        // If result size is different from input string size, rearrangement is not possible
        return result.size() == s.size() ? result : "";
    }
```
#TopK;