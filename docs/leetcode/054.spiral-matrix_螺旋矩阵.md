[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

中等

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

**输入：** matrix = `[[1,2,3],[4,5,6],[7,8,9]]`  
**输出：**[1,2,3,6,9,8,7,4,5]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

**输入：** matrix = `[[1,2,3,4],[5,6,7,8],[9,10,11,12]]`  
**输出：**[1,2,3,4,8,12,11,10,9,5,6,7]

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`
---- ----

模拟：
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix.back().size();
        // 0 n
        // m
        int left = 0;
        int right = n - 1;
        int top = 1;
        int bottom = m - 1;
        int i = 0;
        int j = 0;
        vector<int> res;
        //while (left <= right && top <= bottom) {
        while (i <= right && j <= bottom) {
            if (j > right) break;
            while (j <= right) {
                res.emplace_back(matrix[i][j]);
                j++;
            }
            j=right;
            right--;
            i ++;
            if (i > bottom) break;
            while (i <= bottom) {
                res.emplace_back(matrix[i][j]);
                i++;
            }
            i = bottom;
            bottom--;
            j--;
            if (j < left) break;
            while (j >= left) {
                res.emplace_back(matrix[i][j]);
                j--;
            }
            j = left;
            left++;
            i--;
            if (i < top) break;
            while (i >= top) {
                res.emplace_back(matrix[i][j]);
                i--;
            }
            i = top;
            top++;
            j++;
            // for (auto x: res) cout << x << " ";
            // cout << endl;
            // cout << left << right << top << bottom << endl;
        }
        return res;
    }
};
```

#top-100-liked;