## 1.list链表
### BM1 反转链表 206

[nowcoder反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
栈／双链表／递归
[[206.reverse-linked-list_反转链表]]
[206.reverse-linked-list_反转链表](206.reverse-linked-list_反转链表.md)

### BM2 链表内指定区间反转
[链表内指定区间反转](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tqId=654&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) [[092.reverseBetween_反转链表_II]]
找到m，从m反转到n

### BM3 链表中的节点每k个一组翻转
[链表中的节点每k个一组翻转](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) [[025.Reverse_Nodes_in_k-Group_K个一组翻转链表]]

### BM4 合并两个排序的链表
[合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tqId=23267&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 021 [[021.Merge_Two_Sorted_Lists_合并两个有序链表]]

### BM5 合并k个已排序的链表
[合并k个已排序的链表](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tqId=724&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) [[023.Merge_k_Sorted_Lists_合并 K 个升序链表]]
分而治之

### BM6 判断链表中是否有环
[判断链表中是否有环](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tqId=605&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 141 [[141.Linked_List_Cycle_环形链表]]

### BM7 链表中环的入口结点
[链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tqId=23449&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 142 [[142.Linked_List_Cycle_II_环形链表_II]]

### BM8 链表中倒数最后k个结点
[链表中倒数最后k个结点](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

### BM9 删除链表(倒数第n个节点
[删除链表的倒数第n个节点](https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tqId=727&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 19 [[019.Remove_Nth_Node_From_End_of_List_删除链表的倒数第N个结点]]

### BM10 两个链表的第一个公共结点
[两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tqId=23257&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 160 [[160.Intersection_of_Two_Linked Lists_相交链表]]

### BM11 链表相加(二)
[链表相加(二)](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tqId=1008772&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 445 [[445.Add_Two_Numbers_II_两数相加_II]]

### BM12 单链表的排序
[单链表的排序](https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&tqId=1008897&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 148 [[148.Sort_List_排序链表]]

### BM13 判断一个链表是否为回文结构
[判断一个链表是否为回文结构](https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=295&tqId=1008769&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 234 [[234.Palindrome_Linked_List_回文链表]]

### BM14 链表的奇偶重排
[链表的奇偶重排](https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=295&tqId=1073463&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 328 [[328.Odd_Even_Linked_List_奇偶链表]]

### BM15删除有序链表中重复的元素-I
[删除有序链表中重复的元素-I](https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tqId=664&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 083 [[083.Remove_Duplicates_from_Sorted_List_删除排序链表中的重复元素]]

### BM16删除有序链表中重复的元素-II
[删除有序链表中重复的元素-II](https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=295&tqId=663&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 082 [[082.Remove_Duplicates_from_Sorted_List_II_删除排序链表中的重复元素_II]]

## 二分查找/排序

### BM17 二分查找-I
[二分查找-I](https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&tqId=1499549&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 704 [[704.binary-search_二分查找]] [704](704.binary-search_二分查找.md)

### BM18 二维数组中的查找
[二维数组中的查找](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=295&tqId=23256&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 240 [[240.Search_a_2D_Matrix_II_搜索二维矩阵_II]]

### BM19 寻找峰值
[寻找峰值](https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tqId=2227748&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 162 [[162.Find_Peak_Element_寻找峰值]]

### BM20 数组中的逆序对
[数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tqId=23260&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) [[051.J_reversePairs_数组中的逆序对]]


### BM21 旋转数组的最小数字
[旋转数组的最小数字](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&tqId=23269&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 153/154 [[153.Find_Minimum_in_Rotated_Sorted_Array_寻找旋转排序数组中的最小值]] [[154.Find_Minimum_in_Rotated_Sorted_Array_II_寻找旋转排序数组中的最小值_II]]

### BM22 比较版本号
[比较版本号](https://www.nowcoder.com/practice/2b317e02f14247a49ffdbdba315459e7?tpId=295&tqId=1024572&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 165 [[165.Compare_Version_Numbers_比较版本号]]

## 二叉树


### BM23二叉树的前序遍历

[二叉树的前序遍历](https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635?tpId=295&tqId=2291302&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
递归／非递归（栈 入栈出栈，先放入右子节点）

### BM24二叉树的中序遍历
[二叉树的中序遍历](https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d?tpId=295&tqId=1512964&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
-   step 1：优先判断树是否为空，空树不遍历。
-   step 2：准备辅助栈，当二叉树节点为空了且栈中没有节点了，我们就停止访问。
-   step 3：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
-   step 4：到达最左后，可以开始访问，如果它还有右节点，则将右边也加入栈中，之后右子树的访问也是优先到最左。
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        //辅助栈
        stack<TreeNode*> s;
        //当树节点不为空或栈中有节点时
        while(root != NULL || !s.empty()){
            //每次找到最左节点
            while(root != NULL){
                s.push(root);
                root = root->left;
            }
            //访问该节点
            TreeNode* node = s.top();
            s.pop();
            res.push_back(node->val);
            //进入右节点
            root = node->right;
        }
        return res;
    }
};
```


### BM25二叉树的后序遍历
[二叉树的后序遍历](https://www.nowcoder.com/practice/1291064f4d5d4bdeaefbf0dd47d78541?tpId=295&tqId=2291301&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
-   step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。
-   step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
-   step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。
-   step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。
`二叉树后序遍历使用非递归【不逆转前序遍历的结果】比较麻烦 ，为了防止多次压入有孩子 需要设置一个pre 来判断之前是否压过 其次为了重复压左孩子进来，再每次弹栈后需要将cur设置为NULL`
     
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        //辅助栈
        stack<TreeNode*> s;
        TreeNode* pre = NULL;
        while(root != NULL || !s.empty()){
            //每次先找到最左边的节点
            while(root != NULL){
                s.push(root);
                root = root->left;
            }
            //弹出栈顶
            TreeNode* node = s.top();
            s.pop();
            //如果该元素的右边没有或是已经访问过
            if(node->right == NULL || node->right == pre){
                //访问中间的节点
                res.push_back(node->val);
                //且记录为访问过了
                pre = node;
            }else{
                //该节点入栈
                s.push(node);
                //先访问右边
                root = node->right;
            }
        }
        return res;
    }
};
```

### BM26求二叉树的层序遍历

[求二叉树的层序遍历](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tqId=644&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
队列
```cpp

	/**
 * struct TreeNode {
 *    int val;
 *    struct TreeNode *left;
 *    struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     *
     * @param root TreeNode类
     * @return int整型vector<vector><>>
     */
    vector levelOrder(TreeNode* root) {
        // write code here
        vector res;//存放最终的结果值
        if(root == NULL)
            return res;
        queue<treenode> q;//定义队列
        q.push(root);//将根节点放进去
        while(!q.empty()){
            vector temp;//设立容器
            int n = q.size();//队列中容器的大小
            for(int i = 0; i < n;i++){
                TreeNode* node = q.front();//第一个元素
                q.pop();
                temp.push_back(node->val);//将第一层的值存放到容器当中
                if(node->left != NULL)
                    q.push(node->left);//将左子树放进去
                if(node->right != NULL)
                    q.push(node->right);//将右子树放进去
            }
            res.push_back(temp);
        }
        return res;
    }
};


```

### BM27按之字形顺序打印二叉树

[按之字形顺序打印二叉树](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tqId=23454&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
一个栈反向vector ／ 两个栈

### BM28二叉树的最大深度

[二叉树的最大深度](https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tqId=642&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
层序遍历／递归+1

### BM29二叉树中和为某一值的路径(一)

[二叉树中和为某一值的路径(一)](https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=295&tqId=634&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
dfs
```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(!root) return false;
        sum -= root->val;
        if(!root->left && !root->right){
            if(sum == 0) return true;
            else return false;
        }
        return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);
    }
};

```

### BM30二叉搜索树与双向链表

[二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tqId=23253&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
递归中序遍历
```cpp
class Solution {
public:
    //返回的第一个指针，即为最小值，先定为NULL
    TreeNode* head = NULL; 
    //中序遍历当前值的上一位，初值为最小值，先定为NULL
    TreeNode* pre = NULL;  
    TreeNode* Convert(TreeNode* pRootOfTree) {
        if(pRootOfTree == NULL)
            //中序递归，叶子为空则返回
            return NULL;    
        //首先递归到最左最小值  
        Convert(pRootOfTree->left);
        //找到最小值，初始化head与pre
        if(pre == NULL){      
            head = pRootOfTree;
            pre = pRootOfTree;
        }
        //当前节点与上一节点建立连接，将pre设置为当前值
        else{      
            pre->right = pRootOfTree;
            pRootOfTree->left = pre;
            pre = pRootOfTree;
        }
        Convert(pRootOfTree->right);
        return head;
    }
};
```
中序遍历，使用栈
```cpp
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree) {
        if (pRootOfTree == NULL) {
            return NULL;
        }
        //设置栈用于遍历
        stack<TreeNode*> s;
        TreeNode* head = NULL;
        TreeNode* pre = NULL;
        //确认第一个遍历到最左，即为首位
        bool isFirst = true;
        while(pRootOfTree != NULL || !s.empty()){
            //直到没有左节点
            while(pRootOfTree != NULL){  
                s.push(pRootOfTree);
                pRootOfTree = pRootOfTree->left;
            }
            pRootOfTree = s.top();
            s.pop();
            //首位
            if(isFirst){ 
                head = pRootOfTree;
                pre = head;
                isFirst = false;
            //当前节点与上一节点建立连接，将pre设置为当前值
            }else{         
                pre->right = pRootOfTree;
                pRootOfTree->left = pre;
                pre = pRootOfTree;
            }
            pRootOfTree = pRootOfTree->right;
        }
        return head;
    }
};
```
//Morris Traversal
```cpp
//Morris Traversal
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        TreeNode p = pRootOfTree, pre = null, res = null;
        while (p != null) {
            while (p.left != null) {
                TreeNode q = p.left;
                while (q.right != null) {
                    q = q.right;
                }
                q.right = p;
                TreeNode tmp = p.left;
                p.left = null;
                p = tmp;
            }
            p.left = pre;
            if (pre == null) {
                res = p;
            } else {
                pre.right = p;
            }
            pre = p;
            p = p.right;
        }
        return res;
    }
}
```

### BM31对称的二叉树

[对称的二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tqId=23452&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
递归：
分别判断left和right，value是否相同
```cpp
class Solution {
public:
    bool recursion(TreeNode* root1, TreeNode* root2){
        //可以两个都为空
        if(root1 == NULL && root2 == NULL)
            return true;
        //只有一个为空或者节点值不同，必定不对称
        if(root1 == NULL || root2 == NULL || root1->val != root2->val)
            return false;
        //每层对应的节点进入递归
        return recursion(root1->left, root2->right) && recursion(root1->right, root2->left);
    }
    bool isSymmetrical(TreeNode* pRoot) {
        return recursion(pRoot, pRoot);
    }
};

```
非递归：两边都使用queue，比较对应位置是否相同；
```cpp
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        //空树为对称的
        if(pRoot == NULL)
            return true;
        //辅助队列用于从两边层次遍历
        queue<TreeNode*> q1;
        queue<TreeNode*> q2;
        q1.push(pRoot->left);
        q2.push(pRoot->right);
        while(!q1.empty() && !q2.empty()){
            //分别从左边和右边弹出节点
            TreeNode* left = q1.front();
            q1.pop();
            TreeNode* right = q2.front();
            q2.pop();
            //都为空暂时对称
            if(left == NULL && right == NULL)
                continue;
            //某一个为空或者数字不相等则不对称
            if(left == NULL || right == NULL || left->val != right->val)
                return false;
            //从左往右加入队列
            q1.push(left->left);
            q1.push(left->right);
            //从右往左加入队列
            q2.push(right->right);
            q2.push(right->left);
        }
        //都检验完都是对称的
        return true;
    }
};
```
### BM32合并二叉树

[合并二叉树](https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tqId=1025038&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
递归合并每一个节点，一个为空有一个则返回，另一个也为空为空
```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        //若只有一个节点返回另一个，两个都为NULL自然返回NULL
        if (t1 == NULL)
            return t2;
        if (t2 == NULL)
            return t1;
        //根左右的方式递归
        TreeNode* head = new TreeNode(t1->val + t2->val);
        head->left = mergeTrees(t1->left, t2->left);
        head->right = mergeTrees(t1->right, t2->right);
        return head;
    }
};

```
非递归层次：三个queue，每次依次对比，相加创建新的节点；
```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        //若只有一个节点返回另一个，两个都为NULL自然返回NULL
        if (t1 == NULL)
            return t2;
        if (t2 == NULL)
            return t1;
        //合并根节点
        TreeNode* head = new TreeNode(t1->val + t2->val);
        //连接后的树的层次遍历节点
        queue<TreeNode*> q;
        //分别存两棵树的层次遍历节点
        queue<TreeNode*> q1;
        queue<TreeNode*> q2;
        q.push(head);
        q1.push(t1); 
        q2.push(t2);
        while (!q1.empty() && !q2.empty()) {
            TreeNode *node = q.front(), *node1 = q1.front(), *node2 = q2.front();
            q.pop();
            q1.pop();
            q2.pop();
            TreeNode *left1 = node1->left, *left2 = node2->left, *right1 = node1->right, *right2 = node2->right;
            //两个左节点都存在
            if (left1 || left2) {
                if (left1 && left2) {
                    TreeNode* left = new TreeNode(left1->val + left2->val);
                    node->left = left;
                    //新节点入队列
                    q.push(left);
                    q1.push(left1);
                    q2.push(left2);
                //只连接一个节点
                } else if (left1)
                    node->left = left1;
                  else if (left2)
                    node->left = left2;
            }
            if (right1 || right2) {
                //两个右节点都存在
                if (right1 && right2) {
                    TreeNode* right = new TreeNode(right1->val + right2->val);
                    node->right = right;
                    //新节点入队列
                    q.push(right);
                    q1.push(right1);
                    q2.push(right2);
                //只连接一个节点
                } else if (right1) 
                    node->right = right1;
                  else
                    node->right = right2;
            }
        }
        return head;
    }
};
```
### BM33二叉树的镜像

[二叉树的镜像](https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=295&tqId=1374963&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
递归：分别调用递归左边右边
```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        if(pRoot) //判断边界条件，是否为空树 空树递归结束
        {
            /*交换*/
            TreeNode* temp;//定义一个缓冲指针
            temp=pRoot->left;//缓冲左树
            pRoot->left=pRoot->right;//左树等于右树
            pRoot->right=temp;//右树等于左树（缓冲）
            /*递归*/
            pRoot->left=Mirror(pRoot->left);//递归左树
            pRoot->right=Mirror(pRoot->right);//递归右树
        }
        return pRoot;
    }
};
```
非递归： 左右节点入栈，当前节点交换；
```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        //空树
        if(pRoot == NULL) 
            return NULL;
        //辅助栈
        stack<TreeNode*> s;
        //根节点先进栈
        s.push(pRoot);
        while (!s.empty()){
            TreeNode* node = s.top();
            s.pop();
            //左右节点入栈
            if (node->left != NULL) s.push(node->left);
            if (node->right != NULL) s.push(node->right);
            //交换左右
            TreeNode* temp = node->left; 
            node->left = node->right;
            node->right = temp;
        }
        return pRoot;
    }
};
```
### BM34判断是不是二叉搜索树

[判断是不是二叉搜索树](https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b?tpId=295&tqId=2288088&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
使用中序递归遍历。只要之前的节点是二叉树搜索树，那么如果当前的节点小于上一个节点值那么就可以向下判断。_只不过在过程中我们要求反退出_。比如一个链表1->2->3->4，只要for循环遍历如果中间有不是递增的直接返回false即可。
递归：
-   step 1：首先递归到最左，初始化maxLeft与pre。
-   step 2：然后往后遍历整棵树，依次连接pre与当前节点，并更新pre。
-   step 3：左子树如果不是二叉搜索树返回false。
-   step 4：判断当前节点是不是小于前置节点，更新前置节点。
-   step 5：最后由右子树的后面节点决定。
```cpp
class Solution {
public:
    long pre = INT_MIN;
    //中序遍历
    bool isValidBST(TreeNode* root) {
        if(root == NULL)
            return true;
        //先进入左子树
        if(!isValidBST(root->left))
            return false;
        if(root->val <= pre)
            return false;
        //更新最值
        pre = root->val; 
        //再进入右子树
        if(!isValidBST(root->right)) 
            return false;
        return true;
    }
};
```

### BM35判断是不是完全二叉树

[判断是不是完全二叉树](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=2299105&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
基于层次遍历判断是否为完全二叉树,如果已经遇到null则有标记，若再出现非空则不是完全二叉树；
```java
public boolean isCompleteTree (TreeNode root) {
        // write code here
        if(root == null) return true;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        TreeNode cur;
        boolean flag = false;
        while(!queue.isEmpty()){
            cur = queue.poll();
            if(cur == null){
                flag = true;
                continue;
            }
            if(flag) return false;
            queue.offer(cur.left);
            queue.offer(cur.right);
        }
        return true;
    }
```


### BM36判断是不是平衡二叉树

[判断是不是平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=295&tqId=23250&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
自顶向下
```cpp
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* root) {
        if (!root)
            return true;
        // 分别求左子树和右子树高度
        int leftHeight = getHeight(root->left), rightHeight = getHeight(root->right);
        // 若子树高度之差大于1，返回false
        if (abs(leftHeight - rightHeight) > 1)
            return false;
        // 递归地判断左右子树是否平衡
        return IsBalanced_Solution(root->left) && IsBalanced_Solution(root->right);
    }
    // 求子树高度
    int getHeight(TreeNode* root) {
        if (!root)
            return 0;
        if (!root->left && !root->right)
            return 1; // 叶子结点
        return 1 + max(getHeight(root->left), getHeight(root->right));
    }
};
```
自底向上
```cpp
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* root) {
        if (!root)
            return true;
        // 分别求左子树和右子树高度
        int leftHeight = getHeight(root->left), rightHeight = getHeight(root->right);
        // 若子树高度之差大于1，返回false
        if (abs(leftHeight - rightHeight) > 1)
            return false;
        // 递归地判断左右子树是否平衡
        return IsBalanced_Solution(root->left) && IsBalanced_Solution(root->right);
    }
    // 求子树高度
    int getHeight(TreeNode* root) {
        if (!root)
            return 0;
        if (!root->left && !root->right)
            return 1; // 叶子结点
        return 1 + max(getHeight(root->left), getHeight(root->right));
    }
};
```
### BM37二叉搜索树的最近公共祖先

[二叉搜索树的最近公共祖先](https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=295&tqId=2290592&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
#### 利用vector保存路径
1.直接得到从根节点到两个目标节点的路径，这样我们利用路径比较就可以找到最近公共祖先。

**具体做法：**

-   step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。
-   step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。
-   step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。
```cpp
class Solution {
public:
    //求得根节点到目标节点的路径
    vector<int> getPath(TreeNode* root, int target) {
        vector<int> path;
        TreeNode* node = root;
        //节点值都不同，可以直接用值比较
        while(node->val != target){
            path.push_back(node->val);
            //小的在左子树
            if(target < node->val)
                node = node->left;
            //大的在右子树
            else
                node = node->right;
        }
        path.push_back(node->val);
        return path;
    }
   
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        //求根节点到两个节点的路径
        vector<int> path_p = getPath(root, p);
        vector<int> path_q = getPath(root, q);
        int res;
        //比较两个路径，找到第一个不同的点
        for(int i = 0; i < path_p.size() && i < path_q.size(); i++){
            if(path_p[i] == path_q[i])
                //最后一个相同的节点就是最近公共祖先
                res = path_p[i];
            else
                break;
        }
        return res;
    }
};
```

#### 递归 pq在该节点两边说明这就是最近公共祖先
```cpp
class Solution {
public:
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        //空树找不到公共祖先
        if(root == NULL)
            return -1;
        //pq在该节点两边说明这就是最近公共祖先
        if((p >= root->val && q <= root->val) || (p <= root->val && q >= root->val))
            return root->val;
        //pq都在该节点的左边
        else if(p <= root->val && q <= root->val)
            //进入左子树
            return lowestCommonAncestor(root->left, p, q);
        //pq都在该节点的右边
        else
            //进入右子树
            return lowestCommonAncestor(root->right, p, q);
    }
};
```
#### 非递归，利用二叉搜索树的特点。左子树<根节点<右子树

-   若p,q都比当前结点的值小，说明最近公共祖先结点在当前结点的左子树上，继续检查左子树；
-   若p,q都比当前结点的值大，说明最近公共祖先结点在当前结点的右子树上，继续检查右子树；
-   若p,q中一个比当前结点的值大，另一个比当前结点的值小，则当前结点为最近公共祖先结点
左子树，右子树，
pq都在左边，在左子树找；
直到pq分在两边；
```java
public int lowestCommonAncestor (TreeNode root, int p, int q) {
		TreeNode curnode=root;//当前遍历结点
		while(true) {
			if(p<curnode.val&&q<curnode.val) curnode=curnode.left;//在左子树找
			else if(p>curnode.val&&q>curnode.val) curnode=curnode.right;//在右子树找
			else return curnode.val;
		}
	}

```

### BM38在二叉树中找到两个节点的最近公共祖先

[在二叉树中找到两个节点的最近公共祖先](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=295&tqId=1024325&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

保存两个节点的路径
```cpp
class Solution {
public:
    bool find = false; //标记是否找到了

    void dfs(vector<int>& load, TreeNode* root, int o) {
        if(find || root == nullptr) return; //已经找到或者到达空节点
        load.push_back(root->val); //加入数组
        if(root->val == o) {
            find = true;
            return;
        }
        dfs(load, root->left, o);
        dfs(load, root->right, o);
        if(find) { //防止将节点去除
            return;
        }
        load.pop_back(); //不在这条路径，去除节点
    }

    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        vector<int> load1, load2;
        dfs(load1, root, o1); //找到 root到o1路径
        find = false; //重置标记
        dfs(load2, root, o2); //找到 root到o2路径
        int leng = min(load1.size(), load2.size());
        //寻找最后一个相等节点
        for(int i = 1; i < leng; ++i) {
            if(load1[i] != load2[i]) {
                return load1[i - 1];
            }
        }
        return load1[leng - 1];
    }
};
```
判断是否存在某节点两侧
```cpp
class Solution {
public:
    TreeNode* dfs(TreeNode* root, int o1, int o2) {
        if(root == nullptr) return nullptr; //超过叶节点，返回空
        if(root->val == o1 || root->val == o2) return root; //节点为其中一个
        TreeNode* t1 = dfs(root->left, o1, o2);
        TreeNode* t2 = dfs(root->right, o1, o2);
        if(t1 == nullptr) return t2; //此时两个节点都在右侧
        if(t2 == nullptr) return t1; //此时两个节点都在左侧
        return root; //此时两个节点分别位于左右两侧
    }
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        return dfs(root, o1, o2)->val;
    }
};
```
-   step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。
-   step 2：如果都不匹配，则分别递归左、右子树。
-   step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.
-   step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。
-   step 5：继续递归左、右子树，直到遇到step1或者step3的情况。
递归：
```cpp
class Solution {
public:
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        //该子树没找到，返回-1
        if(root == NULL)
            return -1;
        //该节点是其中某一个节点
        if(root->val == o1 || root->val == o2)
            return root->val;
        //左子树寻找公共祖先
        int left = lowestCommonAncestor(root->left, o1, o2);
        //右子树寻找公共祖先
        int right = lowestCommonAncestor(root->right, o1, o2);
        //左子树为没找到，则在右子树中
        if(left == -1)
            return right;
        //右子树没找到，则在左子树中
        if(right == -1)
            return left;
        //否则是当前节点
        return root->val;
    }
};
```
### BM39序列化二叉树

[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=295&tqId=23455&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
```cpp
class Solution {
public:
    //处理序列化的功能函数（递归）
    void SerializeFunction(TreeNode* root, string& str){
        //如果指针为空，表示左子节点或右子节点为空，用#表示
        if(root == NULL){
            str += '#';
            return;
        }
        //根节点
        string temp = to_string(root->val);
        str += temp + '!';// 加!，区分节点
        //左子树
        SerializeFunction(root->left, str);
        //右子树
        SerializeFunction(root->right, str);
    }
    char* Serialize(TreeNode *root) {
        //处理空树  
        if(root == NULL)
            return "#";
        string res;
        SerializeFunction(root, res);
        //把str转换成char
        char* charRes = new char[res.length() + 1];
        strcpy(charRes, res.c_str());
        charRes[res.length()] = '\0';
        return charRes;
    }
    //处理反序列化的功能函数（递归）
    TreeNode* DeserializeFunction(char** str){
        //到达叶节点时，构建完毕，返回继续构建父节点
        //双**表示取值
        if(**str == '#'){
            (*str)++;
            return NULL;
        }
        //数字转换
        int val = 0;
        while(**str != '!' && **str != '\0'){
            val = val * 10 + ((**str) - '0');
            (*str)++;
        }
        TreeNode* root = new TreeNode(val);
        //序列到底了，构建完成
        if(**str == '\0')
            return root;
        else
            (*str)++;
        //反序列化与序列化一致，都是前序
        root->left = DeserializeFunction(str); 
        root->right = DeserializeFunction(str);
        return root;
    }
    TreeNode* Deserialize(char *str) {
        //空序列对应空树
        if(str == "#"){
            return NULL;
        }
        TreeNode* res = DeserializeFunction(&str);
        return res;
    }
};
```
非递归：
```cpp
class Solution {
public:
    char* Serialize(TreeNode *root)
    {
        string s;
        queue<TreeNode*> qt;
        qt.push(root);

        while (!qt.empty())
        {
            // pop operator
            TreeNode *node = qt.front();
            qt.pop();
            // process null node
            if (node == nullptr)
            {
                s.push_back('#');
                s.push_back(',');
                continue;
            }
            // process not null node
            s += to_string(node->val);
            s.push_back(',');
            // push operator
            qt.push(node->left);
            qt.push(node->right);

        }

        char *ret = new char[s.length() + 1];
        strcpy(ret, s.c_str());

        return ret;
    }
    TreeNode* Deserialize(char *str)
    {
        if (str == nullptr) {
            return nullptr;
        }
        // 可用string成员函数
        string s(str);
        if (str[0] == '#') {
            return nullptr;
        }

        // 构造头结点
        queue<TreeNode*> nodes;
        TreeNode *ret = new TreeNode(atoi(s.c_str()));
        s = s.substr(s.find_first_of(',') + 1);
        nodes.push(ret);
        // 根据序列化字符串再层次遍历一遍，来构造树
        while (!nodes.empty() && !s.empty())
        {
            TreeNode *node = nodes.front();
            nodes.pop();
            if (s[0] == '#')
            {
                node->left = nullptr;
                s = s.substr(2);
            }
            else
            {
                node->left = new TreeNode(atoi(s.c_str()));
                nodes.push(node->left);
                s = s.substr(s.find_first_of(',') + 1);
            }

            if (s[0] == '#')
            {
                node->right = nullptr;
                s = s.substr(2);
            }
            else
            {
                node->right = new TreeNode(atoi(s.c_str()));
                nodes.push(node->right);
                s = s.substr(s.find_first_of(',') + 1);
            }
        }
        return ret;
    }
};
```
### BM40重建二叉树

[重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=295&tqId=23282&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
递归：
```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        int n = pre.size();
        int m = vin.size();
        //每个遍历都不能为0
        if(n == 0 || m == 0)
            return NULL;
        //构建根节点
        TreeNode *root = new TreeNode(pre[0]);
        for(int i = 0; i < vin.size(); i++){
            //找到中序遍历中的前序第一个元素
            if(pre[0] == vin[i]){
                //左子树的前序遍历
                vector<int> leftpre(pre.begin() + 1, pre.begin() + i + 1); 
                //左子树的中序遍历
                vector<int> leftvin(vin.begin(), vin.begin() + i);
                //构建左子树
                root->left = reConstructBinaryTree(leftpre, leftvin);
                //右子树的前序遍历
                vector<int> rightpre(pre.begin() + i + 1, pre.end());
                //右子树的中序遍历
                vector<int> rightvin(vin.begin() + i + 1, vin.end());
                //构建右子树
                root->right = reConstructBinaryTree(rightpre, rightvin);
                break;
            }
        }
        return root;
    }
};
```
非递归：
-   step 1：首先前序遍历第一个数字依然是根节点，并建立栈辅助遍历。
-   step 2：然后我们就开始判断，在前序遍历中相邻的两个数字必定是只有两种情况：要么前序后一个是前一个的左节点；要么前序后一个是前一个的右节点或者其祖先的右节点。
-   step 3：我们可以同时顺序遍历pre和vin两个序列，判断是否是左节点，如果是左节点则不断向左深入，用栈记录祖先，如果不是需要弹出栈回到相应的祖先，然后进入右子树，整个过程类似非递归前序遍历。

### BM41输出二叉树的右视图

[输出二叉树的右视图](https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=295&tqId=1073834&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

**哈希表优化的递归建树+层次遍历** 
**具体做法：** 
对于方法一中每次要寻找中序遍历中的根节点很浪费时间，我们可以利用一个哈希表直接将中序遍历的元素与下标做一个映射，后续查找中序根结点便可以直接访问了。 
同时除了深度优先搜索可以找最右结点，我们也可以利用层次遍历，借助队列，找到每一层的最右。值得注意的是：**每进入一层，队列中的元素个数就是该层的结点数。**因为在上一层他们的父节点将它们加入队列中的，父节点访问完之后，刚好就是这一层的所有结点。因此我们可以用一个size变量，每次进入一层的时候记录当前队列大小，等到size为0时，便到了最右边，记录下该结点元素。
```cpp
class Solution {
public:
    unordered_map<int, int> index;
    //建树函数
    //四个int参数分别是先序最左结点下标，先序最右结点下标
    //中序最左结点下标，中序最右结点坐标
    TreeNode* buildTree(vector<int>& xianxu, int l1, int r1, vector<int>& zhongxu, int l2, int r2)
    {
        if(l1 > r1 || l2 > r2)
            return NULL;
        int xianxu_root = l1;// 前序遍历中的第一个节点就是根节点
        int zhongxu_root = index[xianxu[xianxu_root]];// 在中序遍历中定位根节点
        TreeNode* root = new TreeNode(xianxu[xianxu_root]);
        int leftsize = zhongxu_root - l2;// 得到左子树中的节点数目
        root->left = buildTree(xianxu, l1 + 1, l1 + leftsize, zhongxu, l2, zhongxu_root - 1);
        root->right = buildTree(xianxu, l1 + leftsize + 1, r1, zhongxu, zhongxu_root + 1, r2);
        return root;
    }
    //深度优先搜索函数
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int size = q.size(); //队列中的大小即是这一层的结点树
            while(size--)
            {
                TreeNode* temp = q.front();
                q.pop();             
                if(temp->left)
                    q.push(temp->left);
                if(temp->right)
                    q.push(temp->right);
                if(size == 0) //最右元素
                    res.push_back(temp->val);
            }
        }
        return res;
    }
    vector<int> solve(vector<int>& xianxu, vector<int>& zhongxu) {
        vector<int> res;
        if(xianxu.size() == 0) //空结点
            return res;
        for (int i = 0; i < xianxu.size(); i++) {
            index[zhongxu[i]] = i;
        }
        //建树
        TreeNode* root = buildTree(xianxu, 0, xianxu.size() - 1, zhongxu, 0, zhongxu.size() - 1);
        //找每一层最右边的结点
        return rightSideView(root);
    }
};
```

## 堆/栈/队列


### BM42用两个栈实现队列

[用两个栈实现队列](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=295&tqId=23281&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
**1、**当插入时，直接插入 stack1

2、当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素

队列，先进先出；栈先进后出；
push -> |abc
pop(a)  |cb
push de |de |cb
pop(b)  |de |c
push f  |def|c

```cpp
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int node = stack2.top();
        stack2.pop();
        return node;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```


### BM43包含min函数的栈

[包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=295&tqId=23268&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

增加一个栈保存最小值，如果当前push比min小则插入新min，

or 插入时插入包含min的元组pair

### BM44有效括号序列

[有效括号序列](https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=295&tqId=726&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)


1.通过栈，当遇到`{([`时入栈，期待遇到对应的}，判断栈顶是否为对应右}
```cpp
bool isValid(string s) {
    stack<char> stk;
    for(int i=0;i<s.size();i++){
        switch(s[i]){
            case '(':
            case '[':
            case '{':
                stk.push(s[i]);     //当前字符为'(','{','['时，元素入栈
                break;
            case ')':       
                if(stk.empty() || stk.top() != '(')    //栈空或者括号栈顶字符与当前字符不匹配，则序列为不合法序列
                    return false;
                stk.pop();                   //匹配的栈顶元素出栈
                break;
            case ']':
                if(stk.empty() || stk.top() != '[')
                    return false;
                stk.pop();
                break;
            case '}':
                if(stk.empty() || stk.top() != '{')
                    return false;
                stk.pop();
                break;
        }
    }
    return stk.empty()?true:false;      //当括号以正确顺序关闭时则最后的栈为空
}
```
2.通过栈，遇到{插入}，当出现的字符不是`'(','[','{'`这三种字符时，则先判断栈是否为空或者当前字符是否与栈顶元素一样,当栈空或者当前字符与栈顶字符不一样时，则括号序列不合法，直接返回；否则栈顶元素出栈。遍历字符串直到所有元素遍历完成。最后判断栈是否为空，不为空则括号序列不合法；否则为合法序列。
```cpp
bool isValid(string s) {
    stack<char> stk;
    for(int i=0;i<s.size();i++){
        if(s[i] == '(')           //当为(字符时，将匹配字符入栈，下同
            stk.push(')');
        else if(s[i] == '[')
            stk.push(']');
        else if(s[i] == '{')
            stk.push('}');
        else{                //当字符不是'(','[','{'这三种字符时，则判断当前字符是否与栈顶元素一样(栈非空时)
            if(stk.empty() || s[i] != stk.top())
                return false;
            stk.pop();
        }
    }
    return stk.empty();
}
```

### BM45滑动窗口的最大值239

[滑动窗口的最大值](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=295&tqId=23458&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
#### 优先队列
```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; ++i) {
            q.emplace(nums[i], i);
        }
        vector<int> ans = {q.top().first};
        for (int i = k; i < n; ++i) {
            q.emplace(nums[i], i);
            while (q.top().second <= i - k) {
                q.pop();
            }
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```
#### 暴力解 遍历每个区间求最大值

```cpp
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
        vector<int> ans;
        for(int l = 0; l < num.size() - size + 1; l ++ ) { //枚举左端点
            int r = l + size - 1;                          //计算出对应的右端点
            int maxn = -1;
            for(int i = l; i <= r; i ++ ) maxn = max(maxn, num[i]); //暴力求出每个区间内部的最值
            if(maxn != -1) ans.push_back(maxn);            //将每个区间的最值存入结果数组
        }
        return ans;
    }
};
```
#### 单调队列deque
```cpp
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> ans;
        deque<int> que;
        for(int i = 0; i < num.size(); i ++ ) {  //枚举窗口右端
            //队头是否出队 和 更新队头
            while(!que.empty() && i - que.front() + 1 > size)  que.pop_front();
            //保证队列的单调性
            while(!que.empty() && num[que.back()] <= num[i])  que.pop_back();
            //新元素入队   
            que.push_back(i);
            //当前遍历的长度大于等于窗口窗口长度才开始存储答案
            if(size && i >= size - 1)  ans.push_back(num[que.front()]);
        }
        return ans;
    }
};
```



### BM46最小的K个数

[最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=295&tqId=23263&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
#### 1.排序取前k个
```cpp
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> ret;
        if (k==0 || k>input.size()) return ret;
        sort(input.begin(), input.end());
        return vector<int>({input.begin(), input.begin()+k});  
    }
};
```
#### 2.大根堆
```cpp
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> ret;
        if (k==0 || k > input.size()) return ret;
        priority_queue<int, vector<int>> pq;
        for (const int val : input) {
            if (pq.size() < k) {
                pq.push(val);
            }
            else {
                if (val < pq.top()) {
                    pq.pop();
                    pq.push(val);
                }

            }
        }

        while (!pq.empty()) {
            ret.push_back(pq.top());
            pq.pop();
        }
        return ret;
    }
};
```




### BM47寻找第K大215

[寻找第K大](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=295&tqId=44581&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)[[215.Kth_Largest_Element_in_an_Array 数组中的第K个最大元素]]
#### 快速排序
-   step 1：进行一次快排，大元素在左，小元素在右，得到的中轴p点。
-   step 2：如果 p - low + 1 = k ，那么p点就是第K大。
-   step 3：如果 p - low + 1 > k，则第k大的元素在左半段，更新high = p - 1，执行step 1。
-   step 4：如果 p - low + 1 < k，则第k大的元素在右半段，更新low = p + 1, 且 k = k - (p - low + 1)，排除掉前面部分更大的元素，再执行step 1.
```cpp
class Solution {
public:
    int quickSelect(vector<int>& a, int l, int r, int index) {
        int q = randomPartition(a, l, r);
        if (q == index) {
            return a[q];
        } else {
            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        }
    }

    inline int randomPartition(vector<int>& a, int l, int r) {
        int i = rand() % (r - l + 1) + l;
        swap(a[i], a[r]);
        return partition(a, l, r);
    }

    inline int partition(vector<int>& a, int l, int r) {
        int x = a[r], i = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= x) {
                swap(a[++i], a[j]);
            }
        }
        swap(a[i + 1], a[r]);
        return i + 1;
    }

    int findKthLargest(vector<int>& nums, int k) {
        srand(time(0));
        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
    }
};
```

#### 建堆
建立一个大根堆，做 k - 1 次删除操作后堆顶元素就是我们要找的答案
```cpp
class Solution {
public:
    void maxHeapify(vector<int>& a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        }
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a[i], a[largest]);
            maxHeapify(a, largest, heapSize);
        }
    }

    void buildMaxHeap(vector<int>& a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapSize = nums.size();
        buildMaxHeap(nums, heapSize);
        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
            swap(nums[0], nums[i]);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
};
```
小根堆
```c++
class Solution {
   public:
    int findKthLargest(vector<int>& nums, int k) {
        // 对前k个元素建成小根堆
        for (int i = 0; i < k; i++) {
            swim(nums, i);
        }
        // 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入
        for (int i = k; i < nums.size(); i++) {
            if (nums[i] > nums[0]) {
                swap(nums[0], nums[i]);
                sink(nums, 0, k - 1);
            }
        }
        // 结束后第k个大的数就是小根堆的堆顶
        return nums[0];
    }

   private:
    // 若v1比v2优先度高，返回true
    bool priorityThan(int v1, int v2) { return v1 < v2; }

    // 上浮 从下到上调整堆
    void swim(vector<int>& heap, int i) {
        while (i > 0 && priorityThan(heap[i], heap[(i - 1) / 2])) {
            swap(heap[i], heap[(i - 1) / 2]);
            i = (i - 1) / 2;
        }
    }

    // 下沉 从下到上调整堆
    void sink(vector<int>& heap, int i, int N) {
        while (2 * i + 1 <= N) {
            int j = 2 * i + 1;
            if (j + 1 <= N && priorityThan(heap[j + 1], heap[j])) {
                j++;
            }
            if (priorityThan(heap[i], heap[j])) {
                break;
            }
            swap(heap[i], heap[j]);
            i = j;
        }
    }
};
```

### BM48数据流中的中位数

[数据流中的中位数](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=295&tqId=23457&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```cpp
class Solution {
public:
    std::priority_queue<int> maxq;
    std::priority_queue<int, vector<int>, std::greater<int>> minq;
    void Insert(int num) {
        int size1 = minq.size();
        int size2 = maxq.size();
        if(size2 == 0){
            maxq.push(num);
            return;
        }
        // maxq + minq
        if (size2 == size1) {
            if (minq.top() < num) {
                maxq.push(minq.top());
                minq.pop();
                minq.push(num);
            } else {
                maxq.push(num);
            }
        } else {
            // maxq 多一个
            if (maxq.top() > num) {
                minq.push(maxq.top());
                maxq.pop();
                maxq.push(num);
            } else {
                minq.push(num);
            }
        }
        std::cout << "->"<<num<<"a:"<<maxq.top() << "i:"<<minq.top()<< std::endl;
    }
    double GetMedian() {
        int size1 = minq.size();
        int size2 = maxq.size();
        if(size2 == 0){
            return 0;
        }
        if(size1 == size2){
            return (minq.top() + maxq.top() ) /2.0;
        } else {
            return maxq.top();
        }
    }
};
```



### BM49表达式求值227

[表达式求值](https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=295&tqId=1076787&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)


## 哈希

### BM50

[两数之和](https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=295&tqId=745&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)[

### BM51

[数组中出现次数超过一半的数字](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=295&tqId=23271&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)[

### BM52

[数组中只出现一次的两个数字](https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tqId=1375231&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)[

### BM53
[缺失的第一个正整数](https://www.nowcoder.com/practice/50ec6a5b0e4e45348544348278cdcee5?tpId=295&tqId=2188893&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)[

### BM54

[三数之和](https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=295&tqId=731&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
