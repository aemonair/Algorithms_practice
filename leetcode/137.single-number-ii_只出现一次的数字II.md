[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

中等

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。** 请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

**示例 1：**

**输入：** nums = [2,2,3,2]  
**输出：** 3

**示例 2：**

**输入：** nums = [0,1,0,1,0,1,99]  
**输出：** 99

**提示：**

- `1 <= nums.length <= 3 * 10⁴`
- `-2³¹ <= nums[i] <= 2³¹ - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

---- ----
```
2 2 3 2            6 6 6 3

二进制表示：
0 1 0              1 1 0
0 1 0              1 1 0
0 1 1              1 1 0
0 1 0              0 1 1
------            -------
0 4 1              3 4 1
取模   % 3                % 3
0 1 1 = 3          0 1 1 = 3
```
用的是 异或结果取模；  
针对每个数字，将与1的与结果存入cnts；  
然后根据cnts % 3得到最后的异或结果；

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector<int> cnts(32, 0);
        for(int num: nums) {
            for(int i=0; i<32; i++) {
                cnts[i] += (num >> i) & 1;
            }
        }
        int ans = 0;
        for(int i=0; i<32; i++) {
            if(cnts[i] % 3 != 0) {
                ans |= 1 << i;
            }
        }
        return ans;
    }
};
```

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
};
```

对于异或（模 2 加法）来说，把一个数不断地异或 1，相当于在 0 和 1 之间不断转换，即：  
0 -> 1 -> 0 -> 1 -> ...  
类似地，模 3 加法就是在 0,1,2 之间不断转换，即：  
0 -> 1 -> 2 -> 0 -> 1 -> 2 -> ...  

需要有三个数字的转换；  
a=0, b=0 表示数字 0；  
a=0, b=1 表示数字 1；  
a=1, b=0 表示数字 2。  
那么转换规则就是：

(0,0) → (0,1) → (1,0) → (0,0) → (0,1) → (1,0) → ...

三个步骤；  
针对不同变化情况，  
a == 0 时，只有当 b == 1 时才进行转换为1；(0,1) -> (1,0)  
a == 1 时，只有当 b == 0 时才进行转换为0: (1,0) -> (0,0)  
所以  当 `(a | b) == 0` 时，把 0 赋值给 a，  
当 `(a | b) == 1`时，进行 a ^ x ;  
b == 0 时，发现当a == 0 时，b才发生变化：  

(0, 0) -> (0, 1)  
(0, 1) -> (1, 0)  

而当a == 1时，b不变；  

(1, 0) -> (0, 0)

所以 `~a` 时进行 `b ^ x`;

```cpp
class Solution {
public:
    int singleNumber(vector<int> &nums) {
        int a = 0, b = 0;
        for (int x: nums) {
            int tmp_a = a;
            a = (a ^ x) & (a | b);
            b = (b ^ x) & ~tmp_a;
        }
        return b;
    }
};
```
[一步步推导出位运算公式！-灵茶山艾府](https://leetcode.cn/problems/single-number-ii/solutions/2482832/dai-ni-yi-bu-bu-tui-dao-chu-wei-yun-suan-wnwy/)

在C++中，`<<` 和 `>>` 是位移操作符。它们用于将一个数的二进制表示向左或向右移动指定的位数。

- `<<` 左移操作符：它会将一个数的二进制位向左移动指定的位数，并在右侧补0。例如，`5 << 1` 表示将数字5（二进制为101）向左移动1位，结果是1010（十进制为10）。
- `>>` 右移操作符：它会将一个数的二进制位向右移动指定的位数。对于无符号数或正数，左侧会补0；对于负数，在某些系统上可能会补1（取决于编译器和机器）。例如，`10 >> 1` 表示将数字10（二进制为1010）向右移动1位，结果是101（十进制为5）。

在这个代码片段中：

```cpp
temp[i] += (num >> i) & 1;
```
原始代码中的 `(num >> i) & 1` 是为了获取 `num` 二进制形式中从右到左第 `i+1` 位的值。这个方法直接且有效地实现了目标：统计数组中所有数字每一位上1出现的次数。

`num >> i` 的作用是从 `num` 的二进制表示中获取从右到左第 `i+1` 位的值。然后通过 `& 1` 操作来检查这一位是否为1。如果该位是1，那么 `(num >> i) & 1` 将等于1；如果是0，则结果为0。这个结果会被累加到 `temp[i]` 中，用来统计数组中所有数字的每一位上1出现的总次数。

至于 `num << i` & 1 是否可以替代 `(num >> i) & 1`，答案是不可以。

如果你尝试用 `(num << i) & 1` 并且在之后用 `(i >> 1)`，这实际上是不正确的，因为你首先改变了 `num` 的值（通过左移），然后又试图对 `i` 做右移操作，这不会帮助你恢复原来的位信息。正确的方式应该是始终以一致的方向进行位操作，并确保这些操作能够准确反映你想提取的信息。

因为 `num << i` 会将 `num` 向左移动 `i` 位，这相当于查看 `num` 二进制表示中从左到右第 `i+1` 位的值，而不是从右到左。如果你用 `num << i` 并且 `i` 不为0，那么结果总是会得到 `num` 的高位部分，而这些高位部分与我们关心的单个比特位无关。因此，这里必须使用 `num >> i` 来正确地提取并统计每一位上的1。

简而言之，`num >> i` & 1 是用来检查 `num` 二进制形式中的某一位是否为1，而 `num << i` & 1 则不是等效的操作。

#XOR; #top-interview-150; 
