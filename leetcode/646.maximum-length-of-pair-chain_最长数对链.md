[646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/)

中等

给你一个由 `n` 个数对组成的数对数组 `pairs` ，其中 `pairs[i] = [lefti, righti]` 且 `lefti < righti` 。

现在，我们定义一种 **跟随** 关系，当且仅当 `b < c` 时，数对 `p2 = [c, d]` 才可以跟在 `p1 = [a, b]` 后面。我们用这种形式来构造 **数对链** 。

找出并返回能够形成的 **最长数对链的长度** 。

你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

**示例 1：**

**输入：** pairs = `[[1,2], [2,3], [3,4]]`  
**输出：** 2  
**解释：** 最长的数对链是 [1,2] -> [3,4] 。

**示例 2：**

**输入：** pairs = `[[1,2],[7,8],[4,5]]`  
**输出：** 3  
**解释：** 最长的数对链是 [1,2] -> [4,5] -> [7,8] 。

**提示：**

- `n == pairs.length`
- `1 <= n <= 1000`
- `-1000 <= leftᵢ < rightᵢ <= 1000`
---- ----
动态规划： O(N²) + O(N)
- 排序方式：按区间起点升序排序
- **排序意义**：这种排序方式是为了确保在遍历顺序从左到右处理处理每个区间时，确保当处理第i个区间时，前面所有可能的前驱区间都已被处理，方便查找可以连接的前驱区间
- 具体体现：
    - 使用二维DP数组记录以每个区间结尾的最长链长度
    - 对于每个区间，检查前面所有区间，如果前一个区间的结束小于当前区间的开始，就尝试更新当前区间的DP值
    - 时间复杂度：O(n²)，因为需要双重循环
```cpp
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        int n = pairs.size();
        sort(pairs.begin(), pairs.end());

        vector dp(n, 1);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (pairs[j][1] < pairs[i][0]) {
                    dp[i] = max(dp[j]+1, dp[i]);
                }
            }
        }
        return ranges::max(dp);
    }
};
```

贪心： O(NLogN) + O(N)
- 排序方式：按区间终点升序排序
- **排序意义**：优先选择结束早的区间，尽可能早地结束当前链，为后续留下更多空间（类似会议安排问题）
- 具体体现：
    - 维护一个prev变量记录上一个区间的结束值
    - 遍历时，如果当前区间的开始大于prev，就选择这个区间并更新prev
    - 时间复杂度：O(nlogn)，主要来自排序，遍历只需要一次
```cpp
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [&](vector<int> &a, vector<int> &b) {
            return a[1] < b[1];
            // return a[1]==b[1]? a[0] > b[0]: a[1] < b[1];
        });
        int prev = -1001;
        int res = 0;
        for (auto pair: pairs) {
            if (prev < pair[0]) {
                res++;
                prev = pair[1];
            }
        }
        return res;
    }
};
```

**应用场景示例**：

- 动态规划适用：字符串子序列、路径问题、带权区间调度
- 贪心适用：无重叠区间、用最少数箭射气球、任务调度

**验证排序方式是否正确的小技巧**： 尝试构造测试用例：

1. [[1,2], [3,4], [5,6], [2,3]]
    
    - 动态规划排序后：保持原序
    - 贪心排序后：顺序不变
    - 两种方法都得到4
2. [[1,10], [2,3], [4,5]]
    
    - 动态规划排序后：按起始点排序 [[1,10], [2,3], [4,5]]
        - 结果只能是1（选[1,10]）
    - 贪心排序后：按结束排序 [[2,3], [4,5], [1,10]]
        - 结果2（选[2,3], [4,5]）
    - 这个用例说明当需要最大化数量时，贪心更优

建议：当题目是纯粹的求最大链长度（不要求顺序），优先使用贪心算法。若遇到变形题（比如链需要保持原数组顺序），则用动态规划。

#dynamic-programming;  #greedy;  #LST;