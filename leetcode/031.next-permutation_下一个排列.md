[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

中等

整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]`不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 修改，只允许使用额外常数空间。

**示例 1：**

**输入：** nums = [1,2,3]  
**输出：**[1,3,2]  

**示例 2：**

**输入：** nums = [3,2,1]  
**输出：**[1,2,3]  

**示例 3：**

**输入：** nums = [1,1,5]  
**输出：**[1,5,1]  

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`
---- ----
- 第一步：从右向左找到第一个小于右侧相邻数字的数 `nums[i]`
- 如果找到了，进入第二步；否则跳过第二步，反转整个数组
    - 第二步：从右向左找到 nums[i] 右边最小的大于 nums[i] 的数 nums[j]
    - 交换 nums[i] 和 nums[j]
- 第三步：反转 nums[i+1:]（如果上面跳过第二步，此时 i = -1）

例如：
```cpp
[1,2,3]
第一步找到第一个小于右边的 2<3; 
第二部从右边开始找小于等于2的，第一个就大于2，交换2和3；
1 3 2
reverse 2自己

[1 3 2]
第一步从右向左找到1<3; 
第二部从右边开始第一个就大于1，j=2，交换1和2;
2 3 1 
reverse 3～1
2 1 3

[2 1 3]
第一步从右向左找到 1<3;
第二部从右开始向左找<1的，结果第一个就大于于是，交换1和3；
2 3 1
reverse 3自己

[ 2 3 1]
第一步从右开始找 2<3
第二步从右开始找 1<2; 3>2所以找到了 3，swap交换2和3；
3 2 1
然后reverse 1自己

[3 2 1]
第一步开始从右开始找，没找到；
直接reverse 
[1 2 3]
```


```cpp

[1 2 3 4 5]
第一步， 先找到  4 < 5;
   然后从右边开始找小于4的，但是大于4，于是交换4和5； [1 2 3 5 4]
   然后reverse 原本位置4，(交换后value5)之后的。最后一个。不变；
[1 2 3 5 4] 
第一步找， 找到 3 < 5;
    然后从右开始找小于3的，但是大于3，于是交换3和4，[1 2 4 5 3]
    然后 reverse 原本位置3 (交换后value5)之后的。最后一个。不变；
[1 2 4 3 5]
第一步， 找到 3 < 5;
    然后从右开始找小于3的，但是大于3，于是交换3和5，[1 2 4 5 3]
    然后 reverse 原本位置3 (交换后value5)之后的。最后一个。不变；
[1 2 4 5 3]
第一步， 找到 4 < 5;
    然后从右开始找小于4的，3<4，5>4;于是交换4和5，[1 2 5 4 3]
    然后 reverse 原本位置4(交换后value5)之后的。两个4和3。
[1 2 5 3 4]
第一步， 找到 3 < 4;
    然后从右开始找小于3的，但是4>3;于是交换3和4，[1 2 5 4 3]
    然后 reverse 原本位置3(交换后value4)之后的。最后一个。不变；
[1 2 5 4 3]
第一步， 找到 2 < 5;
    然后从右开始找小于2的，但是3>2;于是交换3和2，[1 3 5 4 2]
    然后 reverse 原本位置2(交换后value3)之后的。5 4 2 。得到 [1 3 2 4 5]
[1 3 2 4 5]
第一步， 找到 4 < 5;
    然后从右开始找小于4的，但是5>4;于是交换4和5，[1 3 2 5 4]
    然后 reverse 原本位置4(交换后value5)之后的。最后一个。不变；
[1 3 2 5 4]
第一步， 找到 2 < 5;
    然后从右开始找小于2的，但是4>2;于是交换4和2，[1 3 4 5 2]
    然后 reverse 原本位置2(交换后value5)之后的。最后一个。不变；
[1 3 4 5 2]
第一步， 找到 4 < 5;
    然后从右开始找小于4的，2<4, 5>4;于是交换5和4，[1 3 5 4 2]
    然后 reverse 原本位置4(交换后value5)之后的。4和2。得到[1 3 5 2 4]
[1 3 5 2 4]
第一步， 找到 2 < 4;
    然后从右开始找小于2的，但是4>2;于是交换2和4，[1 3 5 4 2]
    然后 reverse 原本位置2(交换后value4)之后的。最后一个。不变；
[1 3 5 4 2]
第一步， 找到 3 < 5;
    然后从右开始找小于3的，2<3, 4>3;于是交换4和3，[1 4 5 3 2]
    然后 reverse 原本位置3(交换后value4)之后的。5 3 2。得到[1 4 2 3 5]
[1 4 2 3 5]
第一步， 找到 3 < 5;
    然后从右开始找小于3的，但是5>3;于是交换3和5，[1 4 2 5 3]
    然后 reverse 原本位置3(交换后value5)之后的。最后一个。不变；
[1 4 2 5 3]
第一步， 找到 2 < 5;
    然后从右开始找小于2的，但是3>2;于是交换3和2，[1 4 3 5 2]
    然后 reverse 原本位置2(交换后value3)之后的 5 和2。得到[1 4 3 2 5]
...
```

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();

        // 第一步：从右向左找到第一个小于右侧相邻数字的数 nums[i]
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        cout << i << " "  ;
        if (i >=0) {
            cout << nums[i] << ";" ;
        }

        // 如果找到了，进入第二步；否则跳过第二步，反转整个数组
        if (i >= 0) {
            // 第二步：从右向左找到 nums[i] 右边最小的大于 nums[i] 的数 nums[j]
            int j = n - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            cout << i << " " << "nums[i]" << nums[i] << ";" ;
            cout << j << " " << "nums[j]" << nums[j] << ";" ;


            // 交换 nums[i] 和 nums[j]
            swap(nums[i], nums[j]);
        }

        // 第三步：反转 nums[i+1:]（如果上面跳过第二步，此时 i = -1）
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```
[带你发明下一个排列算法 - 灵茶山艾府](https://leetcode.cn/problems/next-permutation/solutions/3621022/jiao-ni-cong-ling-kai-shi-si-kao-zhe-ti-9qfrq)

#top-100-liked; 